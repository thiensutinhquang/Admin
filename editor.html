<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Tr√¨nh Bi√™n T·∫≠p Giao L√Ω - ƒê·∫ßy ƒê·ªß T√≠nh NƒÉng</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Firebase SDKs -->
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
  <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
  <style>
    html, body {
      height: auto !important; /* ƒê·∫£m b·∫£o chi·ªÅu cao t·ª± ƒë·ªông theo n·ªôi dung */
      min-height: 100% !important; /* ƒê·∫£m b·∫£o chi·ªÅu cao t·ªëi thi·ªÉu l√† 100% c·ªßa viewport */
      overflow-y: auto !important; /* Cho ph√©p cu·ªôn to√†n trang n·∫øu c·∫ßn */
    }
    body {
      font-family: 'Inter', sans-serif; /* S·ª≠ d·ª•ng font Inter */
      background-color: #f5f5f5;
      margin: 0; /* ƒê·∫£m b·∫£o body kh√¥ng c√≥ margin m·∫∑c ƒë·ªãnh */
      padding: 1rem; /* Padding t·ªïng th·ªÉ cho body */
    }
    /* V√πng ch·ª©a n·ªôi dung t·ªïng th·ªÉ */
    #editableContentContainer {
      border: 2px dashed #3b82f6;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background-color: white;
      transition: background 0.2s ease;
      min-height: 400px !important; /* Chi·ªÅu cao t·ªëi thi·ªÉu cho v√πng ch·ªânh s·ª≠a */
      max-height: none !important; /* X√ìA gi·ªõi h·∫°n chi·ªÅu cao t·ªëi ƒëa cho container */
      height: auto !important; /* Chi·ªÅu cao t·ª± ƒë·ªông theo n·ªôi dung */
      overflow-y: visible !important; /* Cho ph√©p cu·ªôn tr√™n body n·∫øu c·∫ßn, kh√¥ng cu·ªôn ri√™ng container */
      position: relative; /* ƒê·∫£m b·∫£o c√°c ph·∫ßn t·ª≠ con tuy·ªát ƒë·ªëi ƒë∆∞·ª£c ch·ª©a */
      z-index: 10; /* ƒê·∫£m b·∫£o v√πng ch·ªânh s·ª≠a n·∫±m tr√™n c√°c ph·∫ßn t·ª≠ kh√°c */
      /* Lo·∫°i b·ªè flexbox ƒë·ªÉ ƒë∆°n gi·∫£n h√≥a lu·ªìng t√†i li·ªáu */
      /* display: flex; */
      /* flex-direction: column; */

      /* C√°c thu·ªôc t√≠nh t·∫°m th·ªùi ƒë·ªÉ ki·ªÉm tra ƒë√£ ƒë∆∞·ª£c lo·∫°i b·ªè */
    }
    #editableContentContainer:focus-within {
      background-color: #ebf8ff;
      outline: none;
    }

    /* V√πng n·ªôi dung c√≥ th·ªÉ ch·ªânh s·ª≠a ch√≠nh (b√™n trong container) */
    #editableContentWrapper {
      width: 100%;
      height: auto; /* ƒê·ªÉ n·ªôi dung t·ª± ƒë·ªãnh nghƒ©a chi·ªÅu cao */
      /* Lo·∫°i b·ªè c√°c thu·ªôc t√≠nh flexbox kh√¥ng c·∫ßn thi·∫øt khi container kh√¥ng ph·∫£i flex */
      /* flex-grow: 1; */
      /* min-height: 0; */
      /* overflow-y: auto; */ /* Container s·∫Ω cu·ªôn, kh√¥ng ph·∫£i wrapper */
      /* Reset c√°c thu·ªôc t√≠nh c√≥ th·ªÉ g√¢y l·ªói t·ª´ HTML g·ªëc */
      position: static !important;
      z-index: auto !important;
      min-height: auto !important;
      max-height: none !important;
      margin-top: 0 !important; /* Quan tr·ªçng: Reset margin-top */
      margin-bottom: 0 !important;
      margin-left: 0 !important;
      margin-right: 0 !important;
      padding: 0; /* ƒê·∫£m b·∫£o kh√¥ng c√≥ padding th·ª´a */
    }

    /* C√°c ph·∫ßn t·ª≠ c√≥ th·ªÉ ch·ªânh s·ª≠a b√™n trong wrapper */
    [contenteditable].editable-area {
      min-height: 1.5em; /* ƒê·∫£m b·∫£o c√≥ chi·ªÅu cao t·ªëi thi·ªÉu cho m·ªói d√≤ng */
      padding: 0.2em; /* Th√™m padding nh·ªè ƒë·ªÉ d·ªÖ click */
      /* ƒê·∫£m b·∫£o c√°c ph·∫ßn t·ª≠ con kh√¥ng c√≥ margin-top l·ªõn */
      margin-top: 0 !important;
      margin-bottom: 0 !important;
    }
    /* Ki·ªÉu d√°ng cho ghi ch√∫ */
    .comment {
      position: relative;
      background-color: #fefcbf;
      padding: 2px 4px;
      border-radius: 4px;
      cursor: pointer;
      display: inline-block; /* ƒê·∫£m b·∫£o ghi ch√∫ kh√¥ng ph√° v·ª° d√≤ng */
    }
    .tooltip {
      position: absolute;
      background-color: #333;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 50;
      white-space: nowrap;
      top: -25px; /* Hi·ªÉn th·ªã tooltip ph√≠a tr√™n ghi ch√∫ */
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }
    .comment:hover .tooltip {
      opacity: 1;
    }
    .btn {
        @apply px-4 py-2 rounded font-semibold transition-colors duration-200;
    }
    .btn-primary {
        @apply bg-blue-600 text-white hover:bg-blue-700;
    }
    .btn-secondary {
        @apply bg-gray-300 text-gray-800 hover:bg-gray-400;
    }
    .btn-success {
        @apply bg-green-600 text-white hover:bg-green-700;
    }
    .btn-warning {
        @apply bg-yellow-500 text-white hover:bg-yellow-600;
    }
  </style>
</head>
<body class="p-4 text-gray-800">

  <div class="max-w-4xl mx-auto space-y-6">
    <h1 class="text-3xl font-bold text-center">üìù Ch·ªânh s·ª≠a b√†i gi·∫£ng Giao L√Ω</h1>

    <!-- File selector -->
    <div class="bg-white p-4 rounded shadow">
      <label class="block font-semibold mb-2">Ch·ªçn t·ªáp HTML t·ª´ GitHub:</label>
      <div class="flex flex-col sm:flex-row gap-2">
        <select id="fileSelect" class="flex-1 border border-gray-300 p-2 rounded"></select>
        <button onclick="fetchFileList()" class="btn btn-secondary">üîÑ T·∫£i danh s√°ch</button>
        <button onclick="loadFile()" class="btn btn-primary">üì• T·∫£i n·ªôi dung</button>
      </div>
      <p id="fileStatusMessage" class="mt-2 text-sm text-green-600 hidden">ƒê√£ ch·ªçn link ƒë√≥ c√≥ k·∫øt n·ªëi.</p>
    </div>

    <!-- Editable content area -->
    <div id="editableContentContainer" class="space-y-4 mt-4 bg-white p-6 rounded-lg shadow-md">
      <!-- N·ªôi dung s·∫Ω ƒë∆∞·ª£c t·∫£i v√†o ƒë√¢y -->
      <p class="text-gray-500">Ch·ªçn m·ªôt t·ªáp ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.</p>
    </div>

    <!-- N√∫t h√†nh ƒë·ªông -->
    <div class="flex justify-between items-center mt-6">
      <div class="flex gap-2">
        <input type="file" id="imageInput" class="hidden" accept="image/*" />
        <button onclick="document.getElementById('imageInput').click()" class="btn btn-success">üñºÔ∏è Ch√®n ·∫£nh t·ª´ Firebase</button>
        <button onclick="addComment()" class="btn btn-warning">ÔøΩ Ghi ch√∫</button>
      </div>
      <div class="flex gap-2">
        <button onclick="saveToLocal()" class="btn btn-secondary">üíæ L∆∞u t·∫°m</button>
        <button onclick="saveContent()" class="btn btn-primary">üì§ L∆∞u n·ªôi dung l√™n GitHub</button>
      </div>
    </div>

    <!-- Ch·∫ø ƒë·ªô xem tr∆∞·ªõc to√†n trang -->
    <div class="flex justify-end gap-3 mt-6">
      <button onclick="showPreviewDevice('desktop')" class="btn btn-secondary">üíª Desktop</button>
      <button onclick="showPreviewDevice('tablet')" class="btn btn-secondary">üì± Tablet</button>
      <button onclick="showPreviewDevice('mobile')" class="btn btn-secondary">üì± Mobile</button>
    </div>

    <!-- N√∫t cu·ªôn xu·ªëng cu·ªëi trang (ƒë·ªÉ ki·ªÉm tra) -->
    <div class="text-center mt-4">
        <button onclick="window.scrollTo(0, document.body.scrollHeight)" class="btn btn-secondary">Cu·ªôn xu·ªëng cu·ªëi trang</button>
    </div>
  </div>

  <!-- Modal xem tr∆∞·ªõc -->
  <div id="previewWrapper" class="fixed inset-0 bg-black bg-opacity-50 hidden justify-center items-center z-50">
    <div class="bg-white rounded-lg shadow-lg w-[90%] h-[90%] overflow-auto p-4 relative">
      <h2 class="text-xl font-bold mb-4">Xem tr∆∞·ªõc b√†i gi·∫£ng</h2>
      <iframe id="previewFrame" class="w-full h-[calc(100%-60px)] border rounded-lg"></iframe>
      <button onclick="hidePreview()" class="absolute top-4 right-4 bg-gray-300 px-3 py-1 rounded-full text-lg font-bold hover:bg-gray-400">‚úñ</button>
    </div>
  </div>

  <script>
    console.log("Script execution started."); // Log khi script b·∫Øt ƒë·∫ßu ch·∫°y

    // X·ª≠ l√Ω l·ªói JavaScript to√†n c·ª•c
    window.onerror = function(message, source, lineno, colno, error) {
      console.error("Global Error Caught:", { message, source, lineno, colno, error });
      alert("ƒê√£ x·∫£y ra l·ªói JavaScript kh√¥ng mong mu·ªën. Vui l√≤ng ki·ªÉm tra console (F12) ƒë·ªÉ bi·∫øt chi ti·∫øt.");
      return true; // NgƒÉn ch·∫∑n x·ª≠ l√Ω l·ªói m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát
    };

    // Firebase Configuration
    const firebaseConfig = {
      apiKey: "AIzaSyAYDG6sVKYbLBzO_iQGwoK9FTH8deJVo3s",
      authDomain: "giaoly-editor.firebaseapp.com",
      projectId: "giaoly-editor",
      storageBucket: "giaoly-editor.appspot.com",
      messagingSenderId: "62184116846",
      appId: "1:62184116846:web:5bd50b4f8a433a066bcc7f"
    };
    firebase.initializeApp(firebaseConfig);
    console.log("Firebase initialized."); // Log sau khi Firebase kh·ªüi t·∫°o

    const editableContentContainer = document.getElementById('editableContentContainer'); 
    let editableContentWrapper; // Bi·∫øn to√†n c·ª•c ƒë·ªÉ tham chi·∫øu ƒë·∫øn wrapper c√≥ th·ªÉ ch·ªânh s·ª≠a

    const fileSelect = document.getElementById('fileSelect');
    const fileStatusMessage = document.getElementById('fileStatusMessage');
    const functionUrl = 'https://us-central1-giaoly-editor.cloudfunctions.net/updateGitHubContent';
    const baseUrl = 'https://thiensutinhquang.github.io/GiaoLy/';

    // Bi·∫øn to√†n c·ª•c ƒë·ªÉ l∆∞u tr·ªØ c·∫•u tr√∫c HTML g·ªëc c·ªßa t·ªáp ƒë∆∞·ª£c t·∫£i
    let originalHtmlTemplate = {
        doctype: '<!DOCTYPE html>',
        htmlOpen: '<html lang="vi">',
        headContent: '',
        bodyOpen: '<body>',
        bodyClose: '</body>',
        htmlClose: '</html>',
        scriptsInBody: '', // S·∫Ω l∆∞u tr·ªØ c√°c script ·ªü cu·ªëi body
        fixedElementsInBody: [] // ƒê·ªÉ l∆∞u tr·ªØ outerHTML c·ªßa c√°c ph·∫ßn t·ª≠ fixed/sticky t·ª´ body
    };

    // Fetch file list from Cloud Function
    async function fetchFileList() {
      console.log("fetchFileList function called."); 
      fileSelect.innerHTML = '<option value="">ƒêang t·∫£i danh s√°ch t·ªáp...</option>';
      fileSelect.disabled = true;
      try {
        const res = await fetch(functionUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ action: 'list_files' })
        });
        const data = await res.json();
        if (!data.success) throw new Error(data.error || "Kh√¥ng l·∫•y ƒë∆∞·ª£c danh s√°ch.");
        fileSelect.innerHTML = '<option value="">-- Ch·ªçn m·ªôt t·ªáp --</option>';
        data.files.forEach(f => {
          const opt = document.createElement('option');
          opt.value = f;
          opt.textContent = f;
          fileSelect.appendChild(opt);
        });
        alert('Danh s√°ch t·ªáp ƒë√£ t·∫£i th√†nh c√¥ng!');
        console.log("Danh s√°ch t·ªáp ƒë√£ t·∫£i th√†nh c√¥ng."); 
      } catch (err) {
        alert("‚ùå L·ªói t·∫£i danh s√°ch t·ªáp: " + err.message);
        console.error("L·ªói t·∫£i danh s√°ch t·ªáp:", err); 
        fileSelect.innerHTML = '<option value="">L·ªói t·∫£i t·ªáp</option>';
      } finally {
        fileSelect.disabled = false;
      }
    }

    // Load selected file content
    async function loadFile() {
      console.log("[loadFile] function called."); 
      const file = fileSelect.value;
      if (!file) {
        alert("Ch·ªçn t·ªáp tr∆∞·ªõc.");
        console.log("[loadFile] No file selected.");
        return;
      }
      fileStatusMessage.classList.add('hidden'); 
      editableContentContainer.innerHTML = '<p class="text-gray-500">ƒêang t·∫£i n·ªôi dung...</p>'; 
      editableContentContainer.style.pointerEvents = 'none'; 
      editableContentContainer.style.paddingTop = '0.5rem'; // Reset padding-top

      try {
        const res = await fetch(baseUrl + file);
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const text = await res.text();
        console.log("[loadFile] Raw HTML content fetched (first 500 chars):", text.substring(0, 500) + "..."); 

        // S·ª≠ d·ª•ng DOMParser ƒë·ªÉ ph√¢n t√≠ch c√∫ ph√°p HTML
        const parser = new DOMParser();
        const doc = parser.parseFromString(text, 'text/html');

        // L∆∞u tr·ªØ doctype, th·∫ª html v√† body g·ªëc v·ªõi t·∫•t c·∫£ c√°c thu·ªôc t√≠nh
        const doctypeNode = doc.doctype;
        originalHtmlTemplate.doctype = doctypeNode ? `<!DOCTYPE ${doctypeNode.name}${doctypeNode.publicId ? ` PUBLIC "${doctypeNode.publicId}"` : ''}${doctypeNode.systemId ? ` "${doctypeNode.systemId}"` : ''}>` : '<!DOCTYPE html>';
        
        // L·∫•y th·∫ª html v√† body g·ªëc v·ªõi t·∫•t c·∫£ thu·ªôc t√≠nh
        originalHtmlTemplate.htmlOpen = doc.documentElement.outerHTML.match(/<html[^>]*>/i)[0];
        originalHtmlTemplate.bodyOpen = doc.body.outerHTML.match(/<body[^>]*>/i)[0];
        originalHtmlTemplate.htmlClose = '</html>'; 
        originalHtmlTemplate.bodyClose = '</body>'; 

        // L∆∞u tr·ªØ n·ªôi dung <head>
        originalHtmlTemplate.headContent = doc.head.innerHTML;

        // Reset fixed elements and scripts for new load
        originalHtmlTemplate.fixedElementsInBody = [];
        originalHtmlTemplate.scriptsInBody = '';
        let fixedOffsetHeight = 0;

        let contentToEdit = ''; // This will hold the HTML string for editableContentWrapper

        // Process direct children of doc.body to separate fixed elements from main content
        const bodyChildren = Array.from(doc.body.children);
        const mainContentFragment = document.createDocumentFragment();

        for (const child of bodyChildren) {
            if (child.tagName === 'HEADER') {
                console.log("[loadFile] Found and storing header:", child.outerHTML.substring(0, 200) + "...");
                originalHtmlTemplate.fixedElementsInBody.push(child.outerHTML);
                // Calculate height for padding
                const tempDivForHeight = document.createElement('div');
                tempDivForHeight.style.visibility = 'hidden';
                tempDivForHeight.style.position = 'absolute';
                document.body.appendChild(tempDivForHeight);
                tempDivForHeight.appendChild(child.cloneNode(true));
                fixedOffsetHeight += tempDivForHeight.firstChild.offsetHeight;
                document.body.removeChild(tempDivForHeight);
            } else if (child.tagName === 'SCRIPT') {
                console.log("[loadFile] Found and storing script:", child.outerHTML.substring(0, 100) + "...");
                originalHtmlTemplate.scriptsInBody += child.outerHTML + '\n';
            } else if (child.classList.contains('min-h-screen')) {
                // This is the main content div that contains all editable sections including the footer
                console.log("[loadFile] Found main content div (div.min-h-screen). Extracting its innerHTML.");
                contentToEdit = child.innerHTML; // Get all children of this div
            } else {
                // If there are other direct children of body that are not header, script, or main content div,
                // they are unexpected or should be treated as part of the editable content if mainContentDiv wasn't found.
                // For gioithieu.html, this block should ideally not be hit for content.
                console.warn("[loadFile] Unexpected direct body child encountered:", child.tagName, child.outerHTML.substring(0, 100));
                // If mainContentDiv was not found, we would append its outerHTML to contentToEdit here.
                // But since we expect min-h-screen to exist, this is mostly for debugging unexpected structures.
            }
        }

        // Apply padding to the editable container based on fixed elements' height
        editableContentContainer.style.paddingTop = `${fixedOffsetHeight + 20}px`; 
        console.log(`[loadFile] Calculated padding-top for editableContentContainer: ${fixedOffsetHeight + 20}px`);

        // L·∫•y ho·∫∑c t·∫°o editableContentWrapper
        editableContentWrapper = document.getElementById('editableContentWrapper');
        if (!editableContentWrapper) {
            editableContentWrapper = document.createElement('div');
            editableContentWrapper.id = 'editableContentWrapper';
            editableContentWrapper.className = 'editable-area'; // √Åp d·ª•ng c√°c reset CSS cho n√≥
            editableContentWrapper.contentEditable = 'true';
            editableContentContainer.innerHTML = ''; // X√≥a n·ªôi dung ban ƒë·∫ßu
            editableContentContainer.appendChild(editableContentWrapper);
            console.log("[loadFile] Created new editableContentWrapper.");
        } else {
            editableContentWrapper.innerHTML = ''; // X√≥a n·ªôi dung c≈©
            console.log("[loadFile] Cleared existing editableContentWrapper.");
        }

        // Set the extracted content to the wrapper
        editableContentWrapper.innerHTML = contentToEdit;
        console.log("[loadFile] Set extracted content to editableContentWrapper.");

        // Reset margins and paddings for top-level children within the wrapper
        Array.from(editableContentWrapper.children).forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
                node.style.setProperty('margin-top', '0px', 'important');
                node.style.setProperty('margin-bottom', '0px', 'important');
                node.style.setProperty('padding-top', '0px', 'important'); 
                node.style.setProperty('padding-bottom', '0px', 'important');
            }
        });
        console.log("[loadFile] Reset margins/paddings for top-level children in editableContentWrapper.");

        // Th√™m onerror cho c√°c th·∫ª ·∫£nh ƒë·ªÉ hi·ªÉn th·ªã placeholder n·∫øu ·∫£nh g·ªëc l·ªói
        Array.from(editableContentWrapper.querySelectorAll('img')).forEach(img => {
            img.onerror = function() {
                this.onerror = null; // NgƒÉn ch·∫∑n v√≤ng l·∫∑p v√¥ h·∫°n n·∫øu placeholder c≈©ng l·ªói
                this.src = `https://placehold.co/${this.width || 100}x${this.height || 100}/cccccc/333333?text=Image+Error`; // ·∫¢nh placeholder
                this.alt = "L·ªói t·∫£i ·∫£nh";
                console.warn(`[loadFile] Image failed to load: ${this.src}. Replaced with placeholder.`);
            };
        });

        console.log("[loadFile] Content remaining in editableContentWrapper after processing (first 500 chars):", editableContentWrapper.innerHTML.substring(0, 500) + "..."); 
        console.log("[loadFile] editableContentWrapper scrollHeight:", editableContentWrapper.scrollHeight, "clientHeight:", editableContentWrapper.clientHeight); // Ki·ªÉm tra chi·ªÅu cao cu·ªôn v√† chi·ªÅu cao hi·ªÉn th·ªã
        console.log("[loadFile] editableContentContainer computed height:", window.getComputedStyle(editableContentContainer).height);
        console.log("[loadFile] editableContentContainer clientHeight:", editableContentContainer.clientHeight, "scrollHeight:", editableContentContainer.scrollHeight);
        
        // Log ki·ªÉm tra ph·∫ßn t·ª≠ cu·ªëi
        const lastElementInWrapper = editableContentWrapper.lastElementChild;
        console.log("Chi·ªÅu cao v√πng n·ªôi dung (editableContentContainer):", editableContentContainer.scrollHeight, editableContentContainer.clientHeight);
        console.log("N·ªôi dung cu·ªëi (editableContentWrapper):", lastElementInWrapper ? lastElementInWrapper.innerText.substring(0, 100) + '...' : '[Kh√¥ng c√≥]');


        fileStatusMessage.textContent = `ƒê√£ ch·ªçn link: ${baseUrl + file}. N·ªôi dung ƒë√£ ƒë∆∞·ª£c t·∫£i.`;
        fileStatusMessage.classList.remove('hidden');
        fileStatusMessage.classList.remove('text-red-600');
        fileStatusMessage.classList.add('text-green-600');
        console.log("[loadFile] File content loaded successfully."); 

      } catch (err) {
        alert("‚ùå L·ªói t·∫£i n·ªôi dung: " + err.message);
        console.error("L·ªói t·∫£i n·ªôi dung:", err); 
        editableContentContainer.innerHTML = '<p class="text-red-500">Kh√¥ng th·ªÉ t·∫£i n·ªôi dung.</p>';
        fileStatusMessage.textContent = `L·ªói t·∫£i n·ªôi dung t·ª´ ${baseUrl + file}.`;
        fileStatusMessage.classList.remove('hidden');
        fileStatusMessage.classList.remove('text-green-600');
        fileStatusMessage.classList.add('text-red-600');
      } finally {
        editableContentContainer.style.pointerEvents = 'auto'; // K√≠ch ho·∫°t l·∫°i ch·ªânh s·ª≠a
        console.log("[loadFile] editableContentContainer pointerEvents set to auto.");
      }
    }

    // Save content to GitHub
    async function saveContent() {
      console.log("saveContent function called."); 
      const html = editableContentWrapper.innerHTML; // L·∫•y n·ªôi dung t·ª´ wrapper
      const filePath = fileSelect.value;
      if (!filePath) {
        alert("Vui l√≤ng ch·ªçn t·ªáp tr∆∞·ªõc khi l∆∞u.");
        console.log("Kh√¥ng c√≥ t·ªáp n√†o ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ l∆∞u.");
        return;
      }

      const commitMessage = prompt("N·ªôi dung commit:", `C·∫≠p nh·∫≠t ${filePath}`);
      if (!commitMessage) {
        alert("Thi·∫øu th√¥ng tin commit.");
        console.log("Th√¥ng ƒëi·ªáp commit b·ªã h·ªßy ho·∫∑c tr·ªëng.");
        return;
      }

      // Tho√°t (escape) c√°c k√Ω t·ª± backtick trong n·ªôi dung HTML
      const escapedHtml = html.replace(/`/g, '\\`');

      // T√°i t·∫°o to√†n b·ªô HTML c·ªßa t·ªáp
      const fullHtmlContent = `
${originalHtmlTemplate.doctype}
${originalHtmlTemplate.htmlOpen}
<head>
    ${originalHtmlTemplate.headContent}
</head>
<body ${originalHtmlTemplate.bodyOpen.match(/<body(.*?)>/i)[1]}>
    ${originalHtmlTemplate.fixedElementsInBody.join('\n')} <!-- Re-insert fixed elements here -->
    <div class="min-h-screen p-4"> <!-- Re-wrap the editable content in its original container -->
        ${escapedHtml}
    </div>
    ${originalHtmlTemplate.scriptsInBody}
</body>
</html>
            `.trim(); // Lo·∫°i b·ªè kho·∫£ng tr·∫Øng th·ª´a ·ªü ƒë·∫ßu/cu·ªëi

      try {
        alert('ƒêang l∆∞u n·ªôi dung l√™n GitHub...');
        const res = await fetch(functionUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'update_file',
            filePath,
            newContent: fullHtmlContent, // G·ª≠i to√†n b·ªô HTML ƒë√£ t√°i t·∫°o
            commitMessage
          })
        });
        const result = await res.json();
        if (result.success) {
          alert("‚úÖ ƒê√£ l∆∞u! Xem commit:\n" + result.commitUrl);
          console.log("N·ªôi dung ƒë√£ l∆∞u th√†nh c√¥ng. Commit URL:", result.commitUrl); 
        } else {
          throw new Error(result.error || "L·ªói kh√¥ng x√°c ƒë·ªãnh t·ª´ Cloud Function.");
        }
      } catch (err) {
        alert("‚ùå L·ªói khi l∆∞u n·ªôi dung:\n" + err.message);
        console.error("L·ªói khi l∆∞u n·ªôi dung:", err); 
      }
    }

    // Comment inline
    function addComment() {
      console.log("addComment function called."); 
      const sel = window.getSelection();
      if (!sel.rangeCount) return;
      const range = sel.getRangeAt(0);
      const span = document.createElement('span');
      const note = prompt("üí¨ Ghi ch√∫:");
      if (!note) return;
      span.className = "comment bg-yellow-200 px-1 rounded"; // Th√™m class cho m√†u n·ªÅn
      span.contentEditable = "false";
      span.title = note;
      span.textContent = range.toString();
      span.onclick = (event) => {
        event.stopPropagation(); // NgƒÉn ch·∫∑n s·ª± ki·ªán click lan ra ngo√†i
        const action = prompt("üìù S·ª≠a ghi ch√∫ ho·∫∑c g√µ 'x√≥a' ƒë·ªÉ xo√°:", span.title);
        if (action === 'x√≥a') span.remove();
        else if (action) span.title = action;
      };
      range.deleteContents();
      range.insertNode(span);
      console.log("Ghi ch√∫ ƒë√£ ƒë∆∞·ª£c th√™m.");
    }

    // Upload image to Firebase
    document.getElementById('imageInput').addEventListener('change', async (e) => {
      console.log("Image input change event triggered."); 
      const file = e.target.files[0];
      if (!file) return;

      alert('ƒêang t·∫£i ·∫£nh l√™n Firebase Storage...');
      try {
        const storageRef = firebase.storage().ref('images/' + Date.now() + '_' + file.name);
        await storageRef.put(file);
        const url = await storageRef.getDownloadURL();
        const img = document.createElement('img');
        img.src = url;
        img.alt = '·∫¢nh ch√®n';
        img.className = "my-4 rounded shadow max-w-full h-auto"; // Th√™m responsive image
        editableContentWrapper.appendChild(img); // Th√™m v√†o wrapper
        alert('‚úÖ ·∫¢nh ƒë√£ ƒë∆∞·ª£c t·∫£i l√™n v√† ch√®n!');
        console.log("·∫¢nh ƒë√£ t·∫£i l√™n v√† ch√®n th√†nh c√¥ng. URL:", url); 
      } catch (err) {
        alert("‚ùå L·ªói t·∫£i ·∫£nh l√™n Firebase: " + err.message);
        console.error("L·ªói t·∫£i ·∫£nh:", err); 
      }
      e.target.value = ""; // X√≥a gi√° tr·ªã input ƒë·ªÉ c√≥ th·ªÉ ch·ªçn l·∫°i c√πng m·ªôt file
    });

    // Preview functionality
    function showPreviewDevice(type) {
      console.log(`showPreviewDevice function called for type: ${type}`); 
      const wrapper = document.getElementById('previewWrapper');
      const frame = document.getElementById('previewFrame');
      let width = "100%";
      if (type === "tablet") width = "768px";
      else if (type === "mobile") width = "375px";

      frame.style.width = width;

      // Reconstruct HTML for preview, similar to saveContent but without escaping backticks
      const previewHtmlContent = `
<!DOCTYPE html>
<html ${originalHtmlTemplate.htmlOpen.match(/<html(.*?)>/i)[1]}>
<head>
    ${originalHtmlTemplate.headContent}
    <style>body{font-family: Inter, sans-serif;padding:1rem;}</style>
</head>
<body ${originalHtmlTemplate.bodyOpen.match(/<body(.*?)>/i)[1]}>
    ${originalHtmlTemplate.fixedElementsInBody.join('\n')} <!-- Re-insert fixed elements for preview -->
    <div class="min-h-screen p-4"> <!-- Re-wrap the editable content in its original container -->
        ${editableContentWrapper.innerHTML} <!-- L·∫•y n·ªôi dung t·ª´ wrapper -->
    </div>
    ${originalHtmlTemplate.scriptsInBody}
</body>
</html>
      `.trim();
      
      frame.srcdoc = previewHtmlContent;
      wrapper.classList.remove('hidden');
      wrapper.classList.add('flex');
      console.log("Xem tr∆∞·ªõc ƒë√£ hi·ªÉn th·ªã.");
    }

    function hidePreview() {
      console.log("hidePreview function called."); 
      document.getElementById('previewWrapper').classList.add('hidden');
      document.getElementById('previewWrapper').classList.remove('flex');
      console.log("Xem tr∆∞·ªõc ƒë√£ ·∫©n.");
    }

    // Save to LocalStorage
    function saveToLocal() {
      console.log("saveToLocal function called."); 
      const html = editableContentWrapper.innerHTML; // L·∫•y n·ªôi dung t·ª´ wrapper
      localStorage.setItem('draftContent', html);
      alert('‚úÖ ƒê√£ l∆∞u t·∫°m n·ªôi dung v√†o tr√¨nh duy·ªát.');
      console.log("N·ªôi dung ƒë√£ l∆∞u t·∫°m v√†o LocalStorage."); 
    }

    // Load content from LocalStorage on DOMContentLoaded
    document.addEventListener('DOMContentLoaded', () => {
      console.log("DOMContentLoaded event fired. Calling fetchFileList."); 
      fetchFileList(); // T·∫£i danh s√°ch t·ªáp khi trang t·∫£i
      const saved = localStorage.getItem('draftContent');
      // ƒê·∫£m b·∫£o editableContentWrapper ƒë∆∞·ª£c kh·ªüi t·∫°o tr∆∞·ªõc khi c·ªë g·∫Øng kh√¥i ph·ª•c n·ªôi dung
      editableContentWrapper = document.getElementById('editableContentWrapper');
      if (!editableContentWrapper) {
          editableContentWrapper = document.createElement('div');
          editableContentWrapper.id = 'editableContentWrapper';
          editableContentWrapper.className = 'editable-area';
          editableContentWrapper.contentEditable = 'true';
          editableContentContainer.innerHTML = '';
          editableContentContainer.appendChild(editableContentWrapper);
          console.log("DOMContentLoaded: Created new editableContentWrapper.");
      }

      if (saved) {
        editableContentWrapper.innerHTML = saved;
        console.log("DOMContentLoaded: Content restored from LocalStorage."); 
      } else {
          editableContentWrapper.innerHTML = '<p class="text-gray-500">Ch·ªçn m·ªôt t·ªáp ƒë·ªÉ b·∫Øt ƒë·∫ßu ch·ªânh s·ª≠a.</p>';
          console.log("DOMContentLoaded: No saved content, showing initial message.");
      }
    });

  </script>
</body>
</html>
ÔøΩ
