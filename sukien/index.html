<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tool Qu·∫£n l√Ω S·ª± ki·ªán ƒêa nƒÉng d√†nh cho Ban L√†m Vi·ªác MSTQ</title>
    
    <!-- Manifest for PWA capabilities -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#1e293b">
    
    <!-- Apple Touch Icons for PWA -->
    <link rel="apple-touch-icon" href="./icon-192.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/icon-180.png">
    <link rel="apple-touch-icon" sizes="152x152" href="./icons/icon-152.png">
    <link rel="apple-touch-icon" sizes="120x120" href="./icons/icon-120.png">
    
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Custom CSS for additional styling -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
        }

        /* General button styles */
        .btn {
            @apply px-4 py-2 rounded-full font-semibold transition-all duration-200 ease-in-out flex items-center justify-center text-center;
        }

        /* Primary button */
        .btn-primary {
            @apply bg-blue-600 text-white hover:bg-blue-700 focus:ring-4 focus:ring-blue-500 focus:ring-opacity-50;
        }

        /* Secondary button */
        .btn-secondary {
            @apply bg-gray-600 text-white hover:bg-gray-700 focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50;
        }

        /* Save button */
        .btn-save {
            @apply bg-green-600 text-white hover:bg-green-700 focus:ring-4 focus:ring-green-500 focus:ring-opacity-50;
        }

        /* Delete button */
        .btn-delete {
            @apply bg-red-600 text-white hover:bg-red-700 focus:ring-4 focus:ring-red-500 focus:ring-opacity-50;
        }

        /* Large button */
        .btn-lg {
            @apply text-lg py-3;
        }

        /* Form input styles */
        .form-input, .form-select {
            @apply w-full p-2.5 rounded-lg bg-gray-700 border border-gray-600 text-white placeholder-gray-400 focus:ring-blue-500 focus:border-blue-500;
        }

        /* Checkbox/Radio styles */
        .form-checkbox, .form-radio {
            @apply h-4 w-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500;
        }

        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            flex-direction: column;
        }

        #loading-text {
            animation: pulse 1.5s infinite ease-in-out;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        /* Toast notifications */
        #toast-container {
            position: fixed;
            top: 1rem;
            right: 1rem;
            z-index: 70;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .toast {
            @apply p-3 rounded-lg shadow-md text-white flex items-center gap-2;
            min-width: 200px;
            max-width: 300px;
            animation: slideIn 0.3s forwards, fadeOut 0.5s forwards 2.5s;
        }

        .toast.success { @apply bg-green-500; }
        .toast.error { @apply bg-red-500; }
        .toast.info { @apply bg-blue-500; }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Tooltip styles */
        [data-tooltip] {
            position: relative;
        }

        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-8px);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            white-space: nowrap;
            z-index: 50;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out;
        }

        [data-tooltip]:hover::after {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* Table specific styles */
        #reportContainer table th, #reportContainer table td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #4a5568; /* gray-700 */
            text-align: left;
        }

        #reportContainer table th {
            font-weight: 600;
        }

        #reportContainer table tbody tr:hover {
            background-color: #2d3748; /* gray-700 */
            cursor: pointer;
        }

        /* Sticky form panel on large screens */
        @media (min-width: 1024px) {
            #form-panel {
                position: sticky;
                top: 1rem; /* Adjust as needed */
                max-height: calc(100vh - 2rem); /* Adjust as needed */
                overflow-y: auto;
            }
        }

        /* Accessibility: Screen reader only class */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }
    </style>
    
    <!-- Chart.js for data visualization -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.0/dist/chart.min.js"></script>
    <!-- SheetJS for Excel export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.2/package/xlsx.full.min.js"></script>
    <!-- html2canvas for image export -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- Sortable.js for drag-and-drop -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 sm:p-6 md:p-8">

    <!-- Loading Overlay -->
    <div id="loading-overlay" class="hidden">
        <div id="loading-text" class="text-white text-lg">ƒêang k·∫øt n·ªëi...</div>
    </div>

    <!-- Toast Notification Container -->
    <div id="toast-container"></div>
    <!-- Screen Reader Announcer -->
    <div id="sr-announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    <!-- Datalists Container (for dynamic datalists) -->
    <div id="datalists-container"></div>

    <div class="max-w-screen-2xl mx-auto">
        <!-- Header Section -->
        <header class="mb-6 text-center relative">
            <h1 class="text-3xl sm:text-4xl font-bold text-white">Tool Qu·∫£n l√Ω S·ª± ki·ªán ƒêa nƒÉng d√†nh cho Ban L√†m Vi·ªác MSTQ</h1>
            <p class="text-gray-400 mt-2">T·∫°o, qu·∫£n l√Ω, v√† t√πy ch·ªânh ho√†n to√†n c·∫•u tr√∫c danh s√°ch.</p>
        </header>

        <!-- Event Selection and Management Section -->
        <section class="bg-gray-800 p-4 rounded-xl shadow-lg mb-8">
            <div class="flex flex-col md:flex-row md:items-center md:justify-between gap-4">
                <div class="flex-grow w-full md:w-auto">
                    <label for="eventSelector" class="block mb-2 text-sm text-white font-medium">üéØ Ch·ªçn s·ª± ki·ªán ƒë√£ t·∫°o:</label>
                    <div class="flex gap-2 items-center">
                        <select id="eventSelector" class="form-select w-full max-w-md">
                            <option disabled selected>ƒêang t·∫£i danh s√°ch s·ª± ki·ªán...</option>
                        </select>
                        <button id="deleteSelectedEventBtn" class="btn btn-delete text-sm" data-tooltip="Xo√° s·ª± ki·ªán ƒë√£ ch·ªçn">üóëÔ∏è Xo√°</button>
                    </div>
                </div>
                <div class="flex flex-col sm:flex-row flex-wrap gap-2 justify-center">
                    <button id="newListBtn" class="btn btn-primary w-full sm:w-auto" data-tooltip="T·∫°o m·ªôt s·ª± ki·ªán m·ªõi">T·∫°o s·ª± ki·ªán m·ªõi</button>
                    <button id="renameListBtn" class="btn btn-secondary w-full sm:w-auto" data-tooltip="ƒê·ªïi t√™n s·ª± ki·ªán hi·ªán t·∫°i">ƒê·ªïi t√™n</button>
                    <button id="shareListBtn" class="btn btn-save w-full sm:w-auto" data-tooltip="Chia s·∫ª s·ª± ki·ªán n√†y ƒë·ªÉ c·ªông t√°c">Chia s·∫ª</button>
                </div>
            </div>
        </section>

        <!-- Main Content Area: Form and Report -->
        <main class="grid grid-cols-1 lg:grid-cols-5 gap-8">
            <!-- Form Panel -->
            <div id="form-panel" class="bg-gray-800 p-6 rounded-xl shadow-lg lg:col-span-2 self-start sticky top-8">
                <h2 id="form-title" class="text-xl font-semibold mb-6 border-b border-gray-700 pb-4 text-center"></h2>
                <form id="registrationForm" class="space-y-6"></form>
                <div id="form-actions" class="pt-5 space-y-3 border-t border-gray-700 mt-5">
                    <button type="button" id="submitBtn" class="btn btn-lg w-full">Th√™m v√†o B√°o c√°o</button>
                    <div id="edit-actions" class="hidden grid grid-cols-2 gap-3">
                        <button type="button" id="deleteFromFormBtn" class="btn btn-delete w-full" data-tooltip="Xo√° m·ª•c ƒëang ƒë∆∞·ª£c ch·ªçn">Xo√° m·ª•c</button>
                        <button type="button" id="cancelEditBtn" class="btn btn-secondary w-full" data-tooltip="Hu·ª∑ ch·ªânh s·ª≠a v√† quay l·∫°i ch·∫ø ƒë·ªô th√™m m·ªõi">Hu·ª∑ b·ªè</button>
                    </div>
                </div>
            </div>

            <!-- Report and Chart Panel -->
            <div class="bg-gray-800 p-6 rounded-xl shadow-lg flex flex-col lg:col-span-3">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-4 gap-4">
                    <div class="flex items-center gap-4">
                        <h2 id="reportTitle" class="text-2xl font-semibold"></h2>
                        <button id="manageColsBtn" class="btn btn-secondary text-xs p-2" data-tooltip="Th√™m, xo√°, ho·∫∑c s·∫Øp x·∫øp c√°c c·ªôt trong b·∫£ng">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mr-1"><path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>
                            Qu·∫£n l√Ω C·ªôt
                        </button>
                    </div>
                    <div class="relative w-full md:w-auto">
                        <button id="actionsToggleBtn" class="btn btn-secondary md:hidden w-full">H√†nh ƒë·ªông...</button>
                        <div id="actionsContainer" class="hidden md:flex flex-col md:flex-row md:items-center gap-2 mt-2 md:mt-0 absolute md:relative bg-gray-700 md:bg-transparent p-2 md:p-0 rounded-md w-full md:w-auto z-10">
                            <button id="exportExcelBtn" class="btn btn-secondary w-full md:w-auto" data-tooltip="Xu·∫•t b√°o c√°o ra file Excel (.xlsx)">Xu·∫•t Excel</button>
                            <button id="exportTxtBtn" class="btn btn-secondary w-full md:w-auto" data-tooltip="Xu·∫•t b√°o c√°o ra file vƒÉn b·∫£n (.txt)">Xu·∫•t TXT</button>
                            <button id="exportJpgBtn" class="btn btn-secondary w-full md:w-auto" data-tooltip="Xu·∫•t b√°o c√°o ra file ·∫£nh (.jpg)">Xu·∫•t ·∫£nh JPG</button>
                            <button id="clearAllBtn" class="btn btn-delete w-full md:w-auto" data-tooltip="Xo√° t·∫•t c·∫£ c√°c m·ª•c trong b·∫£ng b√°o c√°o">Xo√° h·∫øt m·ª•c</button>
                        </div>
                    </div>
                </div>
                <p class="text-gray-400 mt-1 mb-4">T·ªïng s·ªë m·ª•c: <span id="participantCounter" class="font-bold text-white">0</span></p>

                <div id="reportContainer" class="bg-gray-800 overflow-x-auto flex-grow">
                    <table class="w-full text-sm text-gray-300 border-collapse">
                        <thead class="text-xs text-gray-300 uppercase bg-gray-700 sticky top-0">
                            <tr id="reportHeaderRow"></tr>
                        </thead>
                        <tbody id="reportBody"></tbody>
                    </table>
                </div>
                <div class="mt-8">
                    <div class="flex justify-between items-center mb-4">
                        <h3 id="chartTitle" class="text-xl font-semibold"></h3>
                        <div class="flex items-center gap-2">
                            <label for="chartColumnSelector" class="text-sm">Th·ªëng k√™ theo:</label>
                            <select id="chartColumnSelector" class="form-select text-sm py-1 px-2 w-40"></select>
                        </div>
                    </div>
                    <div class="bg-gray-700 p-4 rounded-lg h-80"><canvas id="provinceChart"></canvas></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmModal" class="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-[60] hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <h3 id="modalTitle" class="text-xl font-bold text-white mb-4"></h3>
            <p id="modalMessage" class="text-gray-300 mb-6 whitespace-pre-wrap"></p>
            <div id="modal-input-wrapper" class="mb-4 hidden"><input type="text" id="modalInput" class="form-input"></div>
            <div class="flex justify-end gap-4">
                <button id="cancelBtn" class="btn btn-secondary">Hu·ª∑</button>
                <button id="confirmBtn" class="btn btn-delete">X√°c nh·∫≠n</button>
            </div>
        </div>
    </div>
    
    <!-- Manage Columns Modal -->
    <div id="manageColsModal" class="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50 hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-bold text-white mb-6">Qu·∫£n l√Ω C·ªôt</h3>
            <div id="manageColsForm" class="space-y-4 max-h-96 overflow-y-auto pr-2"></div>
            <button id="addNewColBtn" class="btn btn-primary w-full mt-4">Th√™m C·ªôt M·ªõi</button>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancelManageColsBtn" type="button" class="btn btn-secondary">ƒê√≥ng</button>
                <button id="saveManageColsBtn" type="button" class="btn btn-save">L∆∞u & C·∫≠p nh·∫≠t</button>
            </div>
        </div>
    </div>
    
    <!-- Export Options Modal -->
    <div id="exportOptionsModal" class="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50 hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 id="exportModalTitle" class="text-xl font-bold text-white mb-6">Tu·ª≥ ch·ªçn Xu·∫•t File</h3>
            <div class="space-y-4">
                <div>
                    <label for="signerNameInput" class="block mb-2 text-sm text-gray-300">T√™n Ng∆∞·ªùi k√Ω (Tu·ª≥ ch·ªçn)</label>
                    <input type="text" id="signerNameInput" class="form-input" placeholder="Nh·∫≠p t√™n c·ªßa b·∫°n...">
                </div>
                <div id="logoUploaderContainer">
                    <label for="logoUploader" class="block mb-2 text-sm text-gray-300">Th√™m Logo (Tu·ª≥ ch·ªçn)</label>
                    <input type="file" id="logoUploader" accept="image/*" class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                </div>
                <img id="logoPreview" src="" alt="Logo Preview" class="max-h-20 mx-auto hidden rounded">
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="cancelExportBtn" type="button" class="btn btn-secondary">Hu·ª∑</button>
                <button id="proceedExportBtn" type="button" class="btn btn-primary">Ti·∫øn h√†nh Xu·∫•t</button>
            </div>
        </div>
    </div>
    
    <!-- Share Modal -->
    <div id="shareModal" class="fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50 hidden">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <h3 class="text-xl font-bold text-white mb-4">Chia s·∫ª S·ª± ki·ªán</h3>
            <p class="text-gray-400 mb-4">G·ª≠i li√™n k·∫øt n√†y cho ng∆∞·ªùi kh√°c ƒë·ªÉ h·ªç c√≥ th·ªÉ xem v√† ch·ªânh s·ª≠a c√πng b·∫°n.</p>
            <div class="flex items-center gap-2">
                <input type="text" id="shareLinkInput" readonly class="form-input bg-gray-900">
                <button id="copyShareLinkBtn" class="btn btn-primary" data-tooltip="Sao ch√©p li√™n k·∫øt">
                     <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                </button>
            </div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="closeShareModalBtn" type="button" class="btn btn-secondary">ƒê√≥ng</button>
            </div>
        </div>
    </div>

    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, addDoc, getDocs, writeBatch } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global variables for Firebase instances
        let app;
        let db;
        let auth;
        let userId; // Will store the authenticated user ID or a random ID

        // Function to show toast notifications
        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `<span>${message}</span>`;
            toastContainer.appendChild(toast);

            // Announce to screen readers
            const srAnnouncer = document.getElementById('sr-announcer');
            srAnnouncer.textContent = message;

            setTimeout(() => {
                toast.remove();
                srAnnouncer.textContent = ''; // Clear announcer after toast disappears
            }, 3000);
        }

        // Function to show a custom confirmation modal
        function showConfirmModal(title, message, showInput = false, inputPlaceholder = '') {
            return new Promise(resolve => {
                const modal = document.getElementById('confirmModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalMessage = document.getElementById('modalMessage');
                const modalInputWrapper = document.getElementById('modal-input-wrapper');
                const modalInput = document.getElementById('modalInput');
                const confirmBtn = document.getElementById('confirmBtn');
                const cancelBtn = document.getElementById('cancelBtn');

                modalTitle.textContent = title;
                modalMessage.textContent = message;
                modalInput.value = ''; // Clear previous input

                if (showInput) {
                    modalInputWrapper.classList.remove('hidden');
                    modalInput.placeholder = inputPlaceholder;
                    modalInput.focus();
                } else {
                    modalInputWrapper.classList.add('hidden');
                }

                modal.classList.remove('hidden');

                const onConfirm = () => {
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    resolve(showInput ? modalInput.value : true);
                };

                const onCancel = () => {
                    modal.classList.add('hidden');
                    confirmBtn.removeEventListener('click', onConfirm);
                    cancelBtn.removeEventListener('click', onCancel);
                    resolve(false);
                };

                confirmBtn.addEventListener('click', onConfirm);
                cancelBtn.addEventListener('click', onCancel);
            });
        }

        // --- Core Application Logic ---
        let currentEventId = null;
        let currentEventData = null; // Stores the entire event document
        let currentReportData = []; // Stores the items in the report
        let chartInstance = null; // Chart.js instance

        // Default columns for a new event
        const defaultColumns = [
            { id: 'stt', label: 'STT', type: 'number', required: false, editable: false, show: true },
            { id: 'ten', label: 'T√™n', type: 'text', required: true, editable: true, show: true },
            { id: 'sdt', label: 'S·ªë ƒêi·ªán Tho·∫°i', type: 'tel', required: false, editable: true, show: true },
            { id: 'diachi', label: 'ƒê·ªãa Ch·ªâ', type: 'text', required: false, editable: true, show: true },
            { id: 'ghichu', label: 'Ghi Ch√∫', type: 'textarea', required: false, editable: true, show: true }
        ];

        // DOM Elements
        const loadingOverlay = document.getElementById('loading-overlay');
        const eventSelector = document.getElementById('eventSelector');
        const deleteSelectedEventBtn = document.getElementById('deleteSelectedEventBtn');
        const newListBtn = document.getElementById('newListBtn');
        const renameListBtn = document.getElementById('renameListBtn');
        const shareListBtn = document.getElementById('shareListBtn');

        const formTitle = document.getElementById('form-title');
        const registrationForm = document.getElementById('registrationForm');
        const submitBtn = document.getElementById('submitBtn');
        const editActions = document.getElementById('edit-actions');
        const deleteFromFormBtn = document.getElementById('deleteFromFormBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');

        const reportTitle = document.getElementById('reportTitle');
        const participantCounter = document.getElementById('participantCounter');
        const manageColsBtn = document.getElementById('manageColsBtn');
        const actionsToggleBtn = document.getElementById('actionsToggleBtn');
        const actionsContainer = document.getElementById('actionsContainer');
        const exportExcelBtn = document.getElementById('exportExcelBtn');
        const exportTxtBtn = document.getElementById('exportTxtBtn');
        const exportJpgBtn = document.getElementById('exportJpgBtn');
        const clearAllBtn = document.getElementById('clearAllBtn');
        const reportHeaderRow = document.getElementById('reportHeaderRow');
        const reportBody = document.getElementById('reportBody');
        const chartTitle = document.getElementById('chartTitle');
        const chartColumnSelector = document.getElementById('chartColumnSelector');
        const provinceChartCanvas = document.getElementById('provinceChart');

        // Modals and their elements
        const manageColsModal = document.getElementById('manageColsModal');
        const manageColsForm = document.getElementById('manageColsForm');
        const addNewColBtn = document.getElementById('addNewColBtn');
        const cancelManageColsBtn = document.getElementById('cancelManageColsBtn');
        const saveManageColsBtn = document.getElementById('saveManageColsBtn');

        const exportOptionsModal = document.getElementById('exportOptionsModal');
        const exportModalTitle = document.getElementById('exportModalTitle');
        const signerNameInput = document.getElementById('signerNameInput');
        const logoUploader = document.getElementById('logoUploader');
        const logoPreview = document.getElementById('logoPreview');
        const cancelExportBtn = document.getElementById('cancelExportBtn');
        const proceedExportBtn = document.getElementById('proceedExportBtn');

        const shareModal = document.getElementById('shareModal');
        const shareLinkInput = document.getElementById('shareLinkInput');
        const copyShareLinkBtn = document.getElementById('copyShareLinkBtn');
        const closeShareModalBtn = document.getElementById('closeShareModalBtn');


        // --- Firebase Initialization and Authentication ---
        window.addEventListener('load', async () => {
            loadingOverlay.classList.remove('hidden');
            try {
                // Initialize Firebase app
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in with custom token or anonymously
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                    showToast('ƒêƒÉng nh·∫≠p th√†nh c√¥ng!', 'success');
                } else {
                    await signInAnonymously(auth);
                    showToast('ƒêƒÉng nh·∫≠p ·∫©n danh th√†nh c√¥ng!', 'success');
                }

                // Listen for auth state changes and set userId
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("User ID:", userId);
                        // Now that we have a user ID, load events
                        loadEvents();
                    } else {
                        // User is signed out, handle accordingly (e.g., clear data)
                        userId = null;
                        console.log("User is signed out.");
                        eventSelector.innerHTML = '<option disabled selected>Vui l√≤ng ƒëƒÉng nh·∫≠p ƒë·ªÉ xem s·ª± ki·ªán</option>';
                        showToast('B·∫°n ƒë√£ ƒëƒÉng xu·∫•t. Vui l√≤ng ƒëƒÉng nh·∫≠p l·∫°i.', 'info');
                    }
                    loadingOverlay.classList.add('hidden');
                });

            } catch (error) {
                console.error("L·ªói kh·ªüi t·∫°o Firebase ho·∫∑c ƒëƒÉng nh·∫≠p:", error);
                showToast(`L·ªói: ${error.message}`, 'error');
                loadingOverlay.classList.add('hidden');
            }
        });

        // --- Event Management Functions ---

        /**
         * Generates a unique ID for new events/documents.
         * @returns {string} A unique ID.
         */
        function generateUniqueId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
        }

        /**
         * Gets the Firestore collection reference for events.
         * Uses public collection for shared events, private for user-specific.
         * @param {string} [eventId=null] - If provided, checks if it's a public event.
         * @returns {firebase.firestore.CollectionReference}
         */
        function getEventsCollectionRef(eventId = null) {
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            if (eventId && eventId.startsWith('public_')) {
                return collection(db, `artifacts/${appId}/public/data/events`);
            }
            return collection(db, `artifacts/${appId}/users/${userId}/events`);
        }

        /**
         * Loads existing events from Firestore and populates the event selector.
         */
        async function loadEvents() {
            if (!userId) {
                showToast('Ch∆∞a c√≥ ID ng∆∞·ªùi d√πng. Kh√¥ng th·ªÉ t·∫£i s·ª± ki·ªán.', 'error');
                return;
            }

            eventSelector.innerHTML = '<option disabled selected>ƒêang t·∫£i danh s√°ch s·ª± ki·ªán...</option>';
            try {
                const privateEventsRef = getEventsCollectionRef();
                const privateQuery = query(privateEventsRef);
                const privateSnapshot = await getDocs(privateQuery);

                const publicEventsRef = getEventsCollectionRef('public_'); // Check public collection
                const publicQuery = query(publicEventsRef, where('sharedWith', 'array-contains', userId)); // Only show shared with current user
                const publicSnapshot = await getDocs(publicQuery);

                let events = [];
                privateSnapshot.forEach(doc => {
                    events.push({ id: doc.id, ...doc.data(), type: 'private' });
                });
                publicSnapshot.forEach(doc => {
                    // Ensure public events are not duplicated if already private
                    if (!events.some(e => e.id === doc.id)) {
                        events.push({ id: doc.id, ...doc.data(), type: 'public' });
                    }
                });

                if (events.length === 0) {
                    eventSelector.innerHTML = '<option disabled selected>Ch∆∞a c√≥ s·ª± ki·ªán n√†o. T·∫°o m·ªõi!</option>';
                    currentEventId = null;
                    currentEventData = null;
                    clearReportAndForm();
                    return;
                }

                eventSelector.innerHTML = '';
                events.sort((a, b) => (b.lastModified || 0) - (a.lastModified || 0)); // Sort by last modified

                events.forEach(event => {
                    const option = document.createElement('option');
                    option.value = event.id;
                    option.textContent = event.name + (event.type === 'public' ? ' (Chia s·∫ª)' : '');
                    eventSelector.appendChild(option);
                });

                // Select the first event or a previously selected one
                const storedEventId = localStorage.getItem(`selectedEventId_${userId}`);
                if (storedEventId && events.some(e => e.id === storedEventId)) {
                    eventSelector.value = storedEventId;
                    currentEventId = storedEventId;
                } else {
                    eventSelector.value = events[0].id;
                    currentEventId = events[0].id;
                }
                await loadSelectedEventData(currentEventId);
                showToast('ƒê√£ t·∫£i danh s√°ch s·ª± ki·ªán.', 'info');

            } catch (error) {
                console.error("L·ªói khi t·∫£i s·ª± ki·ªán:", error);
                showToast(`L·ªói khi t·∫£i s·ª± ki·ªán: ${error.message}`, 'error');
            }
        }

        /**
         * Loads data for the currently selected event.
         * @param {string} eventId - The ID of the event to load.
         */
        async function loadSelectedEventData(eventId) {
            loadingOverlay.classList.remove('hidden');
            try {
                currentEventId = eventId;
                localStorage.setItem(`selectedEventId_${userId}`, eventId); // Store selected event

                const eventType = eventId.startsWith('public_') ? 'public' : 'private';
                const eventDocRef = doc(getEventsCollectionRef(eventId), eventId);
                const eventDocSnap = await getDoc(eventDocRef);

                if (eventDocSnap.exists()) {
                    currentEventData = eventDocSnap.data();
                    currentEventData.id = eventDocSnap.id; // Add ID to data
                    currentEventData.type = eventType; // Add type (private/public)

                    formTitle.textContent = `Th√™m m·ª•c v√†o s·ª± ki·ªán "${currentEventData.name}"`;
                    reportTitle.textContent = `B√°o c√°o s·ª± ki·ªán "${currentEventData.name}"`;

                    // Initialize columns if not present (for old events or new ones)
                    if (!currentEventData.columns || currentEventData.columns.length === 0) {
                        currentEventData.columns = defaultColumns;
                    }

                    // Set up real-time listener for report data
                    setupReportListener(eventId);
                    renderForm();
                    renderReportHeader();
                    updateChartColumnSelector();
                    showToast(`ƒê√£ t·∫£i s·ª± ki·ªán "${currentEventData.name}".`, 'success');
                } else {
                    showToast('Kh√¥ng t√¨m th·∫•y s·ª± ki·ªán n√†y!', 'error');
                    currentEventId = null;
                    currentEventData = null;
                    clearReportAndForm();
                    loadEvents(); // Reload event list
                }
            } catch (error) {
                console.error("L·ªói khi t·∫£i d·ªØ li·ªáu s·ª± ki·ªán:", error);
                showToast(`L·ªói khi t·∫£i d·ªØ li·ªáu s·ª± ki·ªán: ${error.message}`, 'error');
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        }

        /**
         * Sets up a real-time listener for the report data of the current event.
         * @param {string} eventId - The ID of the event whose report data to listen to.
         */
        let unsubscribeReport = null; // To store the unsubscribe function

        function setupReportListener(eventId) {
            // Unsubscribe from previous listener if exists
            if (unsubscribeReport) {
                unsubscribeReport();
                console.log("Unsubscribed from previous report listener.");
            }

            if (!userId) {
                console.error("User ID is not available for setting up report listener.");
                return;
            }

            const reportItemsRef = collection(doc(getEventsCollectionRef(eventId), eventId), 'items');
            unsubscribeReport = onSnapshot(reportItemsRef, (snapshot) => {
                const items = [];
                snapshot.forEach(doc => {
                    items.push({ id: doc.id, ...doc.data() });
                });
                currentReportData = items.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0)); // Sort by timestamp
                renderReportTable();
                updateParticipantCounter();
                updateChart();
                console.log("Report data updated in real-time.");
            }, (error) => {
                console.error("L·ªói khi l·∫Øng nghe d·ªØ li·ªáu b√°o c√°o:", error);
                showToast(`L·ªói c·∫≠p nh·∫≠t b√°o c√°o: ${error.message}`, 'error');
            });
        }


        /**
         * Creates a new event.
         */
        async function createNewEvent() {
            const eventName = await showConfirmModal('T·∫°o S·ª± ki·ªán M·ªõi', 'Nh·∫≠p t√™n cho s·ª± ki·ªán m·ªõi c·ªßa b·∫°n:', true, 'T√™n s·ª± ki·ªán');
            if (eventName && eventName.trim()) {
                loadingOverlay.classList.remove('hidden');
                try {
                    const newEventId = generateUniqueId();
                    const newEventData = {
                        name: eventName.trim(),
                        columns: defaultColumns,
                        lastModified: Date.now(),
                        owner: userId, // Store the owner's ID
                        sharedWith: [userId] // Initially shared only with the owner
                    };
                    const eventsCollectionRef = getEventsCollectionRef();
                    await setDoc(doc(eventsCollectionRef, newEventId), newEventData);
                    showToast(`S·ª± ki·ªán "${eventName.trim()}" ƒë√£ ƒë∆∞·ª£c t·∫°o!`, 'success');
                    await loadEvents(); // Reload events to show the new one
                    eventSelector.value = newEventId; // Select the newly created event
                    await loadSelectedEventData(newEventId);
                } catch (error) {
                    console.error("L·ªói khi t·∫°o s·ª± ki·ªán m·ªõi:", error);
                    showToast(`L·ªói khi t·∫°o s·ª± ki·ªán: ${error.message}`, 'error');
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            } else if (eventName !== false) { // If not cancelled explicitly
                showToast('T√™n s·ª± ki·ªán kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.', 'info');
            }
        }

        /**
         * Renames the current event.
         */
        async function renameCurrentEvent() {
            if (!currentEventId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán ƒë·ªÉ ƒë·ªïi t√™n.', 'info');
                return;
            }
            if (currentEventData.owner !== userId) {
                showToast('B·∫°n kh√¥ng c√≥ quy·ªÅn ƒë·ªïi t√™n s·ª± ki·ªán n√†y. Ch·ªâ ch·ªß s·ªü h·ªØu m·ªõi c√≥ th·ªÉ ƒë·ªïi t√™n.', 'error');
                return;
            }

            const newName = await showConfirmModal('ƒê·ªïi T√™n S·ª± ki·ªán', `ƒê·ªïi t√™n s·ª± ki·ªán "${currentEventData.name}" th√†nh:`, true, 'T√™n m·ªõi');
            if (newName && newName.trim()) {
                loadingOverlay.classList.remove('hidden');
                try {
                    const eventDocRef = doc(getEventsCollectionRef(currentEventId), currentEventId);
                    await updateDoc(eventDocRef, { name: newName.trim(), lastModified: Date.now() });
                    showToast(`S·ª± ki·ªán ƒë√£ ƒë∆∞·ª£c ƒë·ªïi t√™n th√†nh "${newName.trim()}".`, 'success');
                    await loadEvents(); // Reload events to update name in selector
                    eventSelector.value = currentEventId; // Keep current event selected
                    await loadSelectedEventData(currentEventId);
                } catch (error) {
                    console.error("L·ªói khi ƒë·ªïi t√™n s·ª± ki·ªán:", error);
                    showToast(`L·ªói khi ƒë·ªïi t√™n s·ª± ki·ªán: ${error.message}`, 'error');
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            } else if (newName !== false) {
                showToast('T√™n kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.', 'info');
            }
        }

        /**
         * Deletes the currently selected event.
         */
        async function deleteSelectedEvent() {
            if (!currentEventId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán ƒë·ªÉ xo√°.', 'info');
                return;
            }
            if (currentEventData.owner !== userId) {
                showToast('B·∫°n kh√¥ng c√≥ quy·ªÅn xo√° s·ª± ki·ªán n√†y. Ch·ªâ ch·ªß s·ªü h·ªØu m·ªõi c√≥ th·ªÉ xo√°.', 'error');
                return;
            }

            const confirm = await showConfirmModal('X√°c nh·∫≠n Xo√°', `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën xo√° s·ª± ki·ªán "${currentEventData.name}" v√† t·∫•t c·∫£ d·ªØ li·ªáu c·ªßa n√≥? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`);
            if (confirm) {
                loadingOverlay.classList.remove('hidden');
                try {
                    const eventDocRef = doc(getEventsCollectionRef(currentEventId), currentEventId);
                    await deleteDoc(eventDocRef);
                    showToast(`S·ª± ki·ªán "${currentEventData.name}" ƒë√£ b·ªã xo√°.`, 'success');
                    currentEventId = null;
                    currentEventData = null;
                    clearReportAndForm();
                    await loadEvents(); // Reload events to remove the deleted one
                } catch (error) {
                    console.error("L·ªói khi xo√° s·ª± ki·ªán:", error);
                    showToast(`L·ªói khi xo√° s·ª± ki·ªán: ${error.message}`, 'error');
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }
        }

        /**
         * Shares the current event with another user by adding their userId to the sharedWith array.
         */
        async function shareCurrentEvent() {
            if (!currentEventId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán ƒë·ªÉ chia s·∫ª.', 'info');
                return;
            }
            if (currentEventData.owner !== userId) {
                showToast('B·∫°n kh√¥ng c√≥ quy·ªÅn chia s·∫ª s·ª± ki·ªán n√†y. Ch·ªâ ch·ªß s·ªü h·ªØu m·ªõi c√≥ th·ªÉ chia s·∫ª.', 'error');
                return;
            }

            // Generate a public ID for the event if it's currently private
            let publicEventId = currentEventId;
            let isPublic = currentEventId.startsWith('public_');

            if (!isPublic) {
                const confirmConvert = await showConfirmModal(
                    'Chuy·ªÉn sang S·ª± ki·ªán Chia s·∫ª?',
                    'ƒê·ªÉ chia s·∫ª s·ª± ki·ªán n√†y, n√≥ c·∫ßn ƒë∆∞·ª£c chuy·ªÉn th√†nh "S·ª± ki·ªán Chia s·∫ª". ƒêi·ªÅu n√†y s·∫Ω cho ph√©p b·∫•t k·ª≥ ai c√≥ li√™n k·∫øt ƒë·ªÅu c√≥ th·ªÉ truy c·∫≠p v√† ch·ªânh s·ª≠a. B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c kh√¥ng?',
                    false
                );
                if (!confirmConvert) {
                    return;
                }

                publicEventId = `public_${currentEventId}`; // Prefix for public events
                loadingOverlay.classList.remove('hidden');
                try {
                    // Copy data to public collection
                    const privateEventDocRef = doc(getEventsCollectionRef(currentEventId), currentEventId);
                    const privateEventDocSnap = await getDoc(privateEventDocRef);
                    if (!privateEventDocSnap.exists()) {
                        showToast('Kh√¥ng t√¨m th·∫•y s·ª± ki·ªán ri√™ng t∆∞ ƒë·ªÉ chuy·ªÉn ƒë·ªïi.', 'error');
                        loadingOverlay.classList.add('hidden');
                        return;
                    }
                    const privateData = privateEventDocSnap.data();

                    const publicEventsCollectionRef = getEventsCollectionRef(publicEventId);
                    const publicEventDocRef = doc(publicEventsCollectionRef, publicEventId);

                    // Add current user to sharedWith if not already there
                    if (!privateData.sharedWith.includes(userId)) {
                        privateData.sharedWith.push(userId);
                    }

                    await setDoc(publicEventDocRef, {
                        ...privateData,
                        owner: userId, // Ensure owner is set to current user
                        sharedWith: privateData.sharedWith // Keep existing shared users
                    });

                    // Copy items from private to public
                    const privateItemsRef = collection(privateEventDocRef, 'items');
                    const publicItemsRef = collection(publicEventDocRef, 'items');
                    const privateItemsSnapshot = await getDocs(privateItemsRef);
                    const batch = writeBatch(db); // Use batch for efficiency

                    privateItemsSnapshot.forEach(itemDoc => {
                        const newItemDocRef = doc(publicItemsRef, itemDoc.id);
                        batch.set(newItemDocRef, itemDoc.data());
                    });
                    await batch.commit();

                    // Delete original private event
                    await deleteDoc(privateEventDocRef);

                    showToast('S·ª± ki·ªán ƒë√£ ƒë∆∞·ª£c chuy·ªÉn ƒë·ªïi th√†nh c√¥ng sang "S·ª± ki·ªán Chia s·∫ª"!', 'success');
                    await loadEvents(); // Reload events to show the public version
                    eventSelector.value = publicEventId; // Select the new public event
                    await loadSelectedEventData(publicEventId);
                    isPublic = true; // Update flag
                    currentEventId = publicEventId; // Update current event ID
                } catch (error) {
                    console.error("L·ªói khi chuy·ªÉn ƒë·ªïi s·ª± ki·ªán sang c√¥ng khai:", error);
                    showToast(`L·ªói khi chuy·ªÉn ƒë·ªïi s·ª± ki·ªán: ${error.message}`, 'error');
                    loadingOverlay.classList.add('hidden');
                    return; // Stop execution if conversion failed
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }

            // Now, show the share link
            shareModal.classList.remove('hidden');
            const shareLink = `${window.location.origin}${window.location.pathname}?eventId=${currentEventId}`;
            shareLinkInput.value = shareLink;
        }


        /**
         * Copies text to clipboard.
         * @param {string} text - The text to copy.
         */
        function copyToClipboard(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('ƒê√£ sao ch√©p li√™n k·∫øt!', 'success');
            } catch (err) {
                console.error('Kh√¥ng th·ªÉ sao ch√©p: ', err);
                showToast('Kh√¥ng th·ªÉ sao ch√©p li√™n k·∫øt.', 'error');
            } finally {
                document.body.removeChild(textarea);
            }
        }

        /**
         * Clears the report table and form.
         */
        function clearReportAndForm() {
            registrationForm.innerHTML = '';
            reportHeaderRow.innerHTML = '';
            reportBody.innerHTML = '';
            participantCounter.textContent = '0';
            formTitle.textContent = 'Ch·ªçn ho·∫∑c t·∫°o s·ª± ki·ªán m·ªõi';
            reportTitle.textContent = 'B√°o c√°o s·ª± ki·ªán';
            currentReportData = [];
            if (chartInstance) {
                chartInstance.destroy();
                chartInstance = null;
            }
            editActions.classList.add('hidden');
            submitBtn.classList.remove('hidden');
        }

        /**
         * Handles event selection change.
         */
        eventSelector.addEventListener('change', (e) => {
            loadSelectedEventData(e.target.value);
        });

        // Event Listeners for Event Management Buttons
        newListBtn.addEventListener('click', createNewEvent);
        renameListBtn.addEventListener('click', renameCurrentEvent);
        deleteSelectedEventBtn.addEventListener('click', deleteSelectedEvent);
        shareListBtn.addEventListener('click', shareCurrentEvent);
        copyShareLinkBtn.addEventListener('click', () => copyToClipboard(shareLinkInput.value));
        closeShareModalBtn.addEventListener('click', () => shareModal.classList.add('hidden'));

        // --- Form and Report Rendering ---

        /**
         * Renders the dynamic form based on currentEventData.columns.
         * @param {Object} [itemToEdit=null] - Optional item data to pre-fill the form for editing.
         */
        function renderForm(itemToEdit = null) {
            if (!currentEventData || !currentEventData.columns) {
                registrationForm.innerHTML = '<p class="text-gray-400 text-center">Vui l√≤ng ch·ªçn ho·∫∑c t·∫°o m·ªôt s·ª± ki·ªán ƒë·ªÉ b·∫Øt ƒë·∫ßu.</p>';
                submitBtn.classList.add('hidden');
                editActions.classList.add('hidden');
                return;
            }

            registrationForm.innerHTML = '';
            submitBtn.classList.remove('hidden');
            editActions.classList.add('hidden');

            currentEventData.columns.filter(col => col.editable).forEach(col => {
                const div = document.createElement('div');
                div.className = 'form-group';

                const label = document.createElement('label');
                label.htmlFor = col.id;
                label.className = 'block mb-2 text-sm text-white font-medium';
                label.textContent = col.label + (col.required ? ' *' : '');
                div.appendChild(label);

                let inputElement;
                if (col.type === 'textarea') {
                    inputElement = document.createElement('textarea');
                    inputElement.rows = 3;
                } else if (col.type === 'select') {
                    inputElement = document.createElement('select');
                    if (col.options && col.options.length > 0) {
                        col.options.forEach(optionText => {
                            const option = document.createElement('option');
                            option.value = optionText;
                            option.textContent = optionText;
                            inputElement.appendChild(option);
                        });
                    }
                } else if (col.type === 'radio') {
                    // Handle radio buttons
                    div.classList.add('flex', 'flex-wrap', 'gap-4', 'items-center');
                    label.classList.remove('mb-2');
                    div.appendChild(label); // Move label inside the flex container

                    if (col.options && col.options.length > 0) {
                        col.options.forEach(optionText => {
                            const radioWrapper = document.createElement('div');
                            radioWrapper.className = 'flex items-center gap-2';
                            const radioInput = document.createElement('input');
                            radioInput.type = 'radio';
                            radioInput.id = `${col.id}-${optionText.replace(/\s/g, '-')}`;
                            radioInput.name = col.id;
                            radioInput.value = optionText;
                            radioInput.className = 'form-radio';
                            
                            const radioLabel = document.createElement('label');
                            radioLabel.htmlFor = radioInput.id;
                            radioLabel.className = 'text-gray-300 text-sm';
                            radioLabel.textContent = optionText;

                            radioWrapper.appendChild(radioInput);
                            radioWrapper.appendChild(radioLabel);
                            div.appendChild(radioWrapper);
                        });
                    }
                    registrationForm.appendChild(div);
                    return; // Skip common input element handling
                } else if (col.type === 'checkbox') {
                    // Handle checkbox (single checkbox for boolean)
                    div.classList.add('flex', 'items-center', 'gap-2');
                    label.classList.remove('mb-2');
                    div.appendChild(label); // Move label inside the flex container

                    inputElement = document.createElement('input');
                    inputElement.type = 'checkbox';
                    inputElement.id = col.id;
                    inputElement.name = col.id;
                    inputElement.className = 'form-checkbox';
                    div.appendChild(inputElement);
                    registrationForm.appendChild(div);
                    return; // Skip common input element handling
                } else if (col.type === 'datalist') {
                    inputElement = document.createElement('input');
                    inputElement.setAttribute('list', `${col.id}-datalist`);
                    const datalist = document.createElement('datalist');
                    datalist.id = `${col.id}-datalist`;
                    if (col.options && col.options.length > 0) {
                        col.options.forEach(optionText => {
                            const option = document.createElement('option');
                            option.value = optionText;
                            datalist.appendChild(option);
                        });
                    }
                    document.getElementById('datalists-container').appendChild(datalist);
                } else {
                    inputElement = document.createElement('input');
                    inputElement.type = col.type;
                }

                inputElement.id = col.id;
                inputElement.name = col.id;
                inputElement.className = 'form-input';
                if (col.required) {
                    inputElement.setAttribute('required', 'true');
                }
                div.appendChild(inputElement);
                registrationForm.appendChild(div);
            });

            // If editing an item, pre-fill the form
            if (itemToEdit) {
                formTitle.textContent = `Ch·ªânh s·ª≠a m·ª•c STT ${itemToEdit.stt}`;
                submitBtn.classList.add('hidden');
                editActions.classList.remove('hidden');
                deleteFromFormBtn.dataset.itemId = itemToEdit.id; // Store ID for deletion

                currentEventData.columns.filter(col => col.editable).forEach(col => {
                    const input = registrationForm.querySelector(`[name="${col.id}"]`);
                    if (input) {
                        if (col.type === 'checkbox') {
                            input.checked = itemToEdit[col.id] || false;
                        } else if (col.type === 'radio') {
                            const radioBtn = registrationForm.querySelector(`input[name="${col.id}"][value="${itemToEdit[col.id]}"]`);
                            if (radioBtn) {
                                radioBtn.checked = true;
                            }
                        } else {
                            input.value = itemToEdit[col.id] || '';
                        }
                    }
                });
            }
        }

        /**
         * Renders the table header based on currentEventData.columns.
         */
        function renderReportHeader() {
            if (!currentEventData || !currentEventData.columns) {
                reportHeaderRow.innerHTML = '';
                return;
            }
            reportHeaderRow.innerHTML = '';
            currentEventData.columns.filter(col => col.show).forEach(col => {
                const th = document.createElement('th');
                th.scope = 'col';
                th.textContent = col.label;
                reportHeaderRow.appendChild(th);
            });
        }

        /**
         * Renders the report table body with currentReportData.
         */
        function renderReportTable() {
            reportBody.innerHTML = '';
            if (currentReportData.length === 0) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td colspan="${currentEventData.columns.filter(col => col.show).length}" class="text-center py-4 text-gray-400">Ch∆∞a c√≥ m·ª•c n√†o trong b√°o c√°o.</td>`;
                reportBody.appendChild(tr);
                return;
            }

            currentReportData.forEach((item, index) => {
                const tr = document.createElement('tr');
                tr.className = 'border-b border-gray-700';
                tr.dataset.itemId = item.id; // Store item ID for editing/deleting

                currentEventData.columns.filter(col => col.show).forEach(col => {
                    const td = document.createElement('td');
                    if (col.id === 'stt') {
                        td.textContent = index + 1; // Auto-increment STT
                    } else {
                        td.textContent = item[col.id] || '';
                    }
                    tr.appendChild(td);
                });

                // Add click listener to each row for editing
                tr.addEventListener('click', () => editReportItem(item.id));
                reportBody.appendChild(tr);
            });
        }

        /**
         * Updates the participant counter.
         */
        function updateParticipantCounter() {
            participantCounter.textContent = currentReportData.length;
        }

        /**
         * Updates the chart column selector with appropriate column options.
         */
        function updateChartColumnSelector() {
            chartColumnSelector.innerHTML = '';
            if (!currentEventData || !currentEventData.columns) return;

            // Only allow columns with type 'text', 'select', 'radio', or 'datalist' for charting
            const chartableColumns = currentEventData.columns.filter(col =>
                col.type === 'text' || col.type === 'select' || col.type === 'radio' || col.type === 'datalist'
            );

            if (chartableColumns.length === 0) {
                chartColumnSelector.innerHTML = '<option value="" disabled selected>Kh√¥ng c√≥ c·ªôt ƒë·ªÉ th·ªëng k√™</option>';
                chartTitle.textContent = 'Th·ªëng k√™';
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                return;
            }

            chartableColumns.forEach(col => {
                const option = document.createElement('option');
                option.value = col.id;
                option.textContent = col.label;
                chartColumnSelector.appendChild(option);
            });

            // Set default selected chart column to the first chartable column
            if (chartableColumns.length > 0) {
                chartColumnSelector.value = chartableColumns[0].id;
                updateChart();
            }
        }

        /**
         * Updates the chart based on the selected column.
         */
        function updateChart() {
            if (!currentEventData || !currentReportData || currentReportData.length === 0) {
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                chartTitle.textContent = 'Th·ªëng k√™';
                return;
            }

            const selectedColumnId = chartColumnSelector.value;
            if (!selectedColumnId) {
                if (chartInstance) {
                    chartInstance.destroy();
                    chartInstance = null;
                }
                chartTitle.textContent = 'Th·ªëng k√™';
                return;
            }

            const counts = {};
            currentReportData.forEach(item => {
                const value = item[selectedColumnId] || 'Kh√¥ng x√°c ƒë·ªãnh';
                counts[value] = (counts[value] || 0) + 1;
            });

            const labels = Object.keys(counts);
            const data = Object.values(counts);

            const selectedColumnLabel = currentEventData.columns.find(col => col.id === selectedColumnId)?.label || selectedColumnId;
            chartTitle.textContent = `Th·ªëng k√™ theo "${selectedColumnLabel}"`;

            if (chartInstance) {
                chartInstance.destroy();
            }

            chartInstance = new Chart(provinceChartCanvas, {
                type: 'bar', // Can be 'pie', 'doughnut', 'line', etc.
                data: {
                    labels: labels,
                    datasets: [{
                        label: `S·ªë l∆∞·ª£ng theo ${selectedColumnLabel}`,
                        data: data,
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.6)',
                            'rgba(54, 162, 235, 0.6)',
                            'rgba(255, 206, 86, 0.6)',
                            'rgba(75, 192, 192, 0.6)',
                            'rgba(153, 102, 255, 0.6)',
                            'rgba(255, 159, 64, 0.6)',
                            'rgba(199, 199, 199, 0.6)'
                        ],
                        borderColor: [
                            'rgba(255, 99, 132, 1)',
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 206, 86, 1)',
                            'rgba(75, 192, 192, 1)',
                            'rgba(153, 102, 255, 1)',
                            'rgba(255, 159, 64, 1)',
                            'rgba(199, 199, 199, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#E2E8F0' // gray-200
                            }
                        },
                        title: {
                            display: true,
                            text: `Th·ªëng k√™ theo ${selectedColumnLabel}`,
                            color: '#E2E8F0' // gray-200
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#A0AEC0' // gray-400
                            },
                            grid: {
                                color: '#4A5568' // gray-700
                            }
                        },
                        y: {
                            ticks: {
                                color: '#A0AEC0' // gray-400
                            },
                            grid: {
                                color: '#4A5568' // gray-700
                            }
                        }
                    }
                }
            });
        }

        // Event listener for chart column selector
        chartColumnSelector.addEventListener('change', updateChart);

        // --- Report Item Management (Add, Edit, Delete) ---

        let editingItemId = null; // Stores the ID of the item being edited

        /**
         * Handles form submission to add or update a report item.
         */
        submitBtn.addEventListener('click', async () => {
            if (!currentEventId) {
                showToast('Vui l√≤ng ch·ªçn ho·∫∑c t·∫°o m·ªôt s·ª± ki·ªán tr∆∞·ªõc.', 'info');
                return;
            }

            const formData = {};
            let isValid = true;
            currentEventData.columns.filter(col => col.editable).forEach(col => {
                const input = registrationForm.querySelector(`[name="${col.id}"]`);
                if (input) {
                    if (col.type === 'checkbox') {
                        formData[col.id] = input.checked;
                    } else if (col.type === 'radio') {
                        const selectedRadio = registrationForm.querySelector(`input[name="${col.id}"]:checked`);
                        formData[col.id] = selectedRadio ? selectedRadio.value : '';
                    } else {
                        formData[col.id] = input.value.trim();
                    }

                    if (col.required && !formData[col.id] && col.type !== 'checkbox') { // Checkbox required handled differently
                        isValid = false;
                        input.classList.add('border-red-500'); // Highlight invalid input
                    } else {
                        input.classList.remove('border-red-500');
                    }
                }
            });

            if (!isValid) {
                showToast('Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß c√°c tr∆∞·ªùng b·∫Øt bu·ªôc.', 'error');
                return;
            }

            loadingOverlay.classList.remove('hidden');
            try {
                const reportItemsRef = collection(doc(getEventsCollectionRef(currentEventId), currentEventId), 'items');

                if (editingItemId) {
                    // Update existing item
                    const itemDocRef = doc(reportItemsRef, editingItemId);
                    await updateDoc(itemDocRef, { ...formData, lastModified: Date.now() });
                    showToast('ƒê√£ c·∫≠p nh·∫≠t m·ª•c b√°o c√°o!', 'success');
                } else {
                    // Add new item
                    await addDoc(reportItemsRef, { ...formData, timestamp: Date.now() });
                    showToast('ƒê√£ th√™m m·ª•c m·ªõi v√†o b√°o c√°o!', 'success');
                }

                // Clear form and reset to add mode
                registrationForm.reset();
                renderForm(); // Re-render to clear form and reset state
                editingItemId = null;
            } catch (error) {
                console.error("L·ªói khi th√™m/c·∫≠p nh·∫≠t m·ª•c b√°o c√°o:", error);
                showToast(`L·ªói: ${error.message}`, 'error');
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        });

        /**
         * Sets the form to edit an existing report item.
         * @param {string} itemId - The ID of the item to edit.
         */
        async function editReportItem(itemId) {
            if (!currentEventId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán tr∆∞·ªõc.', 'info');
                return;
            }

            const itemToEdit = currentReportData.find(item => item.id === itemId);
            if (itemToEdit) {
                editingItemId = itemId;
                renderForm(itemToEdit);
                submitBtn.classList.add('hidden');
                editActions.classList.remove('hidden');
                deleteFromFormBtn.dataset.itemId = itemToEdit.id; // Set item ID for delete button
                window.scrollTo({ top: 0, behavior: 'smooth' }); // Scroll to form
            } else {
                showToast('Kh√¥ng t√¨m th·∫•y m·ª•c ƒë·ªÉ ch·ªânh s·ª≠a.', 'error');
            }
        }

        /**
         * Deletes a report item from the form (when in edit mode).
         */
        deleteFromFormBtn.addEventListener('click', async () => {
            if (!editingItemId) return;

            const confirm = await showConfirmModal('X√°c nh·∫≠n Xo√°', 'B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën xo√° m·ª•c n√†y kh·ªèi b√°o c√°o?');
            if (confirm) {
                loadingOverlay.classList.remove('hidden');
                try {
                    const itemDocRef = doc(collection(doc(getEventsCollectionRef(currentEventId), currentEventId), 'items'), editingItemId);
                    await deleteDoc(itemDocRef);
                    showToast('ƒê√£ xo√° m·ª•c kh·ªèi b√°o c√°o.', 'success');
                    registrationForm.reset();
                    renderForm(); // Re-render to clear form and reset state
                    editingItemId = null;
                } catch (error) {
                    console.error("L·ªói khi xo√° m·ª•c b√°o c√°o:", error);
                    showToast(`L·ªói: ${error.message}`, 'error');
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }
        });

        /**
         * Cancels editing and reverts the form to add new item mode.
         */
        cancelEditBtn.addEventListener('click', () => {
            registrationForm.reset();
            renderForm(); // Re-render to clear form and reset state
            editingItemId = null;
            showToast('ƒê√£ hu·ª∑ ch·ªânh s·ª≠a.', 'info');
        });

        /**
         * Clears all items from the current report.
         */
        clearAllBtn.addEventListener('click', async () => {
            if (!currentEventId) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán tr∆∞·ªõc.', 'info');
                return;
            }
            if (currentReportData.length === 0) {
                showToast('B√°o c√°o ƒë√£ tr·ªëng.', 'info');
                return;
            }

            const confirm = await showConfirmModal('X√°c nh·∫≠n Xo√° T·∫•t c·∫£', `B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën xo√° t·∫•t c·∫£ ${currentReportData.length} m·ª•c kh·ªèi b√°o c√°o "${currentEventData.name}"? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.`);
            if (confirm) {
                loadingOverlay.classList.remove('hidden');
                try {
                    const reportItemsRef = collection(doc(getEventsCollectionRef(currentEventId), currentEventId), 'items');
                    const snapshot = await getDocs(reportItemsRef);
                    const batch = writeBatch(db);
                    snapshot.forEach((doc) => {
                        batch.delete(doc.ref);
                    });
                    await batch.commit();
                    showToast('ƒê√£ xo√° t·∫•t c·∫£ m·ª•c kh·ªèi b√°o c√°o.', 'success');
                    // Data will be updated via onSnapshot listener
                } catch (error) {
                    console.error("L·ªói khi xo√° t·∫•t c·∫£ m·ª•c b√°o c√°o:", error);
                    showToast(`L·ªói: ${error.message}`, 'error');
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            }
        });

        // --- Column Management Modal ---

        /**
         * Opens the column management modal and populates it.
         */
        manageColsBtn.addEventListener('click', () => {
            if (!currentEventData) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán ƒë·ªÉ qu·∫£n l√Ω c·ªôt.', 'info');
                return;
            }
            if (currentEventData.owner !== userId) {
                showToast('B·∫°n kh√¥ng c√≥ quy·ªÅn qu·∫£n l√Ω c·ªôt s·ª± ki·ªán n√†y. Ch·ªâ ch·ªß s·ªü h·ªØu m·ªõi c√≥ th·ªÉ qu·∫£n l√Ω.', 'error');
                return;
            }

            manageColsForm.innerHTML = '';
            // Create a temporary array to work with, allowing reordering
            const tempColumns = JSON.parse(JSON.stringify(currentEventData.columns));

            tempColumns.forEach((col, index) => {
                const colDiv = document.createElement('div');
                colDiv.className = 'bg-gray-700 p-3 rounded-lg flex items-center gap-3 mb-2 cursor-grab';
                colDiv.dataset.colId = col.id; // Store original ID for reordering

                const handle = document.createElement('span');
                handle.className = 'text-gray-400 cursor-grab';
                handle.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
                colDiv.appendChild(handle);

                const nameInput = document.createElement('input');
                nameInput.type = 'text';
                nameInput.value = col.label;
                nameInput.placeholder = 'T√™n c·ªôt';
                nameInput.className = 'form-input flex-grow';
                nameInput.dataset.colIndex = index;
                nameInput.dataset.colProperty = 'label';
                colDiv.appendChild(nameInput);

                const typeSelect = document.createElement('select');
                typeSelect.className = 'form-select w-32';
                typeSelect.dataset.colIndex = index;
                typeSelect.dataset.colProperty = 'type';
                const types = ['text', 'number', 'tel', 'email', 'date', 'textarea', 'select', 'radio', 'checkbox', 'datalist'];
                types.forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                    typeSelect.appendChild(option);
                });
                typeSelect.value = col.type;
                colDiv.appendChild(typeSelect);

                // Options input for select/radio/datalist
                const optionsInput = document.createElement('input');
                optionsInput.type = 'text';
                optionsInput.placeholder = 'Options (comma-separated)';
                optionsInput.className = 'form-input flex-grow';
                optionsInput.dataset.colIndex = index;
                optionsInput.dataset.colProperty = 'options';
                if (col.options && Array.isArray(col.options)) {
                    optionsInput.value = col.options.join(', ');
                }
                if (col.type === 'select' || col.type === 'radio' || col.type === 'datalist') {
                    optionsInput.classList.remove('hidden');
                } else {
                    optionsInput.classList.add('hidden');
                }
                colDiv.appendChild(optionsInput);

                // Event listener to toggle options input visibility
                typeSelect.addEventListener('change', () => {
                    if (typeSelect.value === 'select' || typeSelect.value === 'radio' || typeSelect.value === 'datalist') {
                        optionsInput.classList.remove('hidden');
                    } else {
                        optionsInput.classList.add('hidden');
                        optionsInput.value = ''; // Clear options if type changes
                    }
                });

                const requiredCheckbox = document.createElement('input');
                requiredCheckbox.type = 'checkbox';
                requiredCheckbox.checked = col.required;
                requiredCheckbox.className = 'form-checkbox';
                requiredCheckbox.dataset.colIndex = index;
                requiredCheckbox.dataset.colProperty = 'required';
                const requiredLabel = document.createElement('label');
                requiredLabel.className = 'text-gray-300 text-sm flex items-center gap-1';
                requiredLabel.innerHTML = `<input type="checkbox" ${col.required ? 'checked' : ''} class="form-checkbox" data-col-index="${index}" data-col-property="required"> B·∫Øt bu·ªôc`;
                colDiv.appendChild(requiredLabel);

                const showCheckbox = document.createElement('input');
                showCheckbox.type = 'checkbox';
                showCheckbox.checked = col.show;
                showCheckbox.className = 'form-checkbox';
                showCheckbox.dataset.colIndex = index;
                showCheckbox.dataset.colProperty = 'show';
                const showLabel = document.createElement('label');
                showLabel.className = 'text-gray-300 text-sm flex items-center gap-1';
                showLabel.innerHTML = `<input type="checkbox" ${col.show ? 'checked' : ''} class="form-checkbox" data-col-index="${index}" data-col-property="show"> Hi·ªÉn th·ªã`;
                colDiv.appendChild(showLabel);

                // Disable editing for STT column
                if (col.id === 'stt') {
                    nameInput.disabled = true;
                    typeSelect.disabled = true;
                    requiredCheckbox.disabled = true;
                    showCheckbox.disabled = true;
                    requiredLabel.classList.add('opacity-50', 'cursor-not-allowed');
                    showLabel.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    // Delete button for non-STT columns
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'btn btn-delete text-xs p-1 rounded-full';
                    deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6l-12 12M6 6l12 12"></path></svg>';
                    deleteBtn.addEventListener('click', () => {
                        colDiv.remove();
                        // Mark for deletion or handle immediately if needed
                        tempColumns[index] = null; // Mark as deleted
                    });
                    colDiv.appendChild(deleteBtn);
                }

                manageColsForm.appendChild(colDiv);
            });

            // Initialize Sortable.js
            Sortable.create(manageColsForm, {
                animation: 150,
                handle: '.cursor-grab',
                ghostClass: 'bg-gray-600',
                onEnd: (evt) => {
                    // Update tempColumns order based on new DOM order
                    const newOrder = Array.from(manageColsForm.children).map(el => el.dataset.colId);
                    const reorderedColumns = [];
                    newOrder.forEach(id => {
                        const originalCol = tempColumns.find(col => col && col.id === id);
                        if (originalCol) {
                            reorderedColumns.push(originalCol);
                        }
                    });
                    // Replace tempColumns with the reordered array
                    tempColumns.length = 0;
                    tempColumns.push(...reorderedColumns);
                }
            });

            manageColsModal.classList.remove('hidden');
        });

        /**
         * Adds a new column entry to the manage columns modal.
         */
        addNewColBtn.addEventListener('click', () => {
            const newIndex = manageColsForm.children.length;
            const newColId = `col_${generateUniqueId()}`;
            const colDiv = document.createElement('div');
            colDiv.className = 'bg-gray-700 p-3 rounded-lg flex items-center gap-3 mb-2 cursor-grab';
            colDiv.dataset.colId = newColId;

            const handle = document.createElement('span');
            handle.className = 'text-gray-400 cursor-grab';
            handle.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>';
            colDiv.appendChild(handle);

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = '';
            nameInput.placeholder = 'T√™n c·ªôt m·ªõi';
            nameInput.className = 'form-input flex-grow';
            nameInput.dataset.colIndex = newIndex;
            nameInput.dataset.colProperty = 'label';
            colDiv.appendChild(nameInput);

            const typeSelect = document.createElement('select');
            typeSelect.className = 'form-select w-32';
            typeSelect.dataset.colIndex = newIndex;
            typeSelect.dataset.colProperty = 'type';
            const types = ['text', 'number', 'tel', 'email', 'date', 'textarea', 'select', 'radio', 'checkbox', 'datalist'];
            types.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                typeSelect.appendChild(option);
            });
            typeSelect.value = 'text'; // Default type
            colDiv.appendChild(typeSelect);

            const optionsInput = document.createElement('input');
            optionsInput.type = 'text';
            optionsInput.placeholder = 'Options (comma-separated)';
            optionsInput.className = 'form-input flex-grow hidden'; // Hidden by default
            optionsInput.dataset.colIndex = newIndex;
            optionsInput.dataset.colProperty = 'options';
            colDiv.appendChild(optionsInput);

            typeSelect.addEventListener('change', () => {
                if (typeSelect.value === 'select' || typeSelect.value === 'radio' || typeSelect.value === 'datalist') {
                    optionsInput.classList.remove('hidden');
                } else {
                    optionsInput.classList.add('hidden');
                    optionsInput.value = '';
                }
            });

            const requiredLabel = document.createElement('label');
            requiredLabel.className = 'text-gray-300 text-sm flex items-center gap-1';
            requiredLabel.innerHTML = `<input type="checkbox" class="form-checkbox" data-col-index="${newIndex}" data-col-property="required"> B·∫Øt bu·ªôc`;
            colDiv.appendChild(requiredLabel);

            const showLabel = document.createElement('label');
            showLabel.className = 'text-gray-300 text-sm flex items-center gap-1';
            showLabel.innerHTML = `<input type="checkbox" checked class="form-checkbox" data-col-index="${newIndex}" data-col-property="show"> Hi·ªÉn th·ªã`;
            colDiv.appendChild(showLabel);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'btn btn-delete text-xs p-1 rounded-full';
            deleteBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 6l-12 12M6 6l12 12"></path></svg>';
            deleteBtn.addEventListener('click', () => colDiv.remove());
            colDiv.appendChild(deleteBtn);

            manageColsForm.appendChild(colDiv);
        });

        /**
         * Saves the updated column configuration.
         */
        saveManageColsBtn.addEventListener('click', async () => {
            if (!currentEventId) return;

            const updatedColumns = [];
            let isValid = true;

            Array.from(manageColsForm.children).forEach(colDiv => {
                const labelInput = colDiv.querySelector('[data-col-property="label"]');
                const typeSelect = colDiv.querySelector('[data-col-property="type"]');
                const requiredCheckbox = colDiv.querySelector('[data-col-property="required"]');
                const showCheckbox = colDiv.querySelector('[data-col-property="show"]');
                const optionsInput = colDiv.querySelector('[data-col-property="options"]');

                if (!labelInput || !typeSelect || !requiredCheckbox || !showCheckbox) {
                    isValid = false;
                    showToast('L·ªói: M·ªôt s·ªë tr∆∞·ªùng c·ªôt b·ªã thi·∫øu.', 'error');
                    return;
                }

                const label = labelInput.value.trim();
                const type = typeSelect.value;
                const required = requiredCheckbox.checked;
                const show = showCheckbox.checked;
                const options = optionsInput && optionsInput.value ? optionsInput.value.split(',').map(opt => opt.trim()).filter(opt => opt) : [];

                if (!label) {
                    isValid = false;
                    labelInput.classList.add('border-red-500');
                    showToast('T√™n c·ªôt kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.', 'error');
                    return;
                } else {
                    labelInput.classList.remove('border-red-500');
                }

                updatedColumns.push({
                    id: colDiv.dataset.colId, // Keep original ID or new ID
                    label: label,
                    type: type,
                    required: required,
                    editable: true, // All custom columns are editable
                    show: show,
                    options: options.length > 0 ? options : undefined // Only add options if present
                });
            });

            if (!isValid) return;

            // Ensure 'STT' column is always present and first, and not editable/deletable
            const sttCol = defaultColumns.find(col => col.id === 'stt');
            if (sttCol && !updatedColumns.some(col => col.id === 'stt')) {
                updatedColumns.unshift(sttCol); // Add STT back if somehow removed
            } else if (sttCol) {
                // Ensure STT is first and properties are fixed
                const currentSttIndex = updatedColumns.findIndex(col => col.id === 'stt');
                if (currentSttIndex !== -1) {
                    const currentStt = updatedColumns.splice(currentSttIndex, 1)[0];
                    updatedColumns.unshift({ ...currentStt, editable: false, show: true, required: false });
                }
            }


            loadingOverlay.classList.remove('hidden');
            try {
                const eventDocRef = doc(getEventsCollectionRef(currentEventId), currentEventId);
                await updateDoc(eventDocRef, { columns: updatedColumns, lastModified: Date.now() });
                showToast('ƒê√£ c·∫≠p nh·∫≠t c·∫•u h√¨nh c·ªôt!', 'success');
                manageColsModal.classList.add('hidden');
                await loadSelectedEventData(currentEventId); // Reload to apply new columns
            } catch (error) {
                console.error("L·ªói khi l∆∞u c·∫•u h√¨nh c·ªôt:", error);
                showToast(`L·ªói khi l∆∞u c·ªôt: ${error.message}`, 'error');
            } finally {
                loadingOverlay.classList.add('hidden');
            }
        });

        cancelManageColsBtn.addEventListener('click', () => {
            manageColsModal.classList.add('hidden');
        });

        // --- Export Functions ---

        let currentExportType = ''; // To store which export button was clicked

        // Show export options modal
        exportExcelBtn.addEventListener('click', () => { currentExportType = 'excel'; exportModalTitle.textContent = 'Tu·ª≥ ch·ªçn Xu·∫•t Excel'; exportOptionsModal.classList.remove('hidden'); });
        exportTxtBtn.addEventListener('click', () => { currentExportType = 'txt'; exportModalTitle.textContent = 'Tu·ª≥ ch·ªçn Xu·∫•t TXT'; exportOptionsModal.classList.remove('hidden'); });
        exportJpgBtn.addEventListener('click', () => { currentExportType = 'jpg'; exportModalTitle.textContent = 'Tu·ª≥ ch·ªçn Xu·∫•t ·∫£nh JPG'; exportOptionsModal.classList.remove('hidden'); });

        // Handle logo preview
        logoUploader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    logoPreview.src = e.target.result;
                    logoPreview.classList.remove('hidden');
                };
                reader.readAsDataURL(file);
            } else {
                logoPreview.src = '';
                logoPreview.classList.add('hidden');
            }
        });

        // Cancel export options
        cancelExportBtn.addEventListener('click', () => {
            exportOptionsModal.classList.add('hidden');
            signerNameInput.value = '';
            logoUploader.value = '';
            logoPreview.src = '';
            logoPreview.classList.add('hidden');
        });

        // Proceed with export based on selected type
        proceedExportBtn.addEventListener('click', () => {
            exportOptionsModal.classList.add('hidden');
            const signerName = signerNameInput.value.trim();
            const logoBase64 = logoPreview.src;

            if (currentExportType === 'excel') {
                exportToExcel(signerName, logoBase64);
            } else if (currentExportType === 'txt') {
                exportToTxt(signerName, logoBase64);
            } else if (currentExportType === 'jpg') {
                exportToJpg(signerName, logoBase64);
            }

            // Reset options after export
            signerNameInput.value = '';
            logoUploader.value = '';
            logoPreview.src = '';
            logoPreview.classList.add('hidden');
        });


        /**
         * Exports the report data to an Excel file.
         * @param {string} signerName - Optional name of the signer.
         * @param {string} logoBase64 - Optional base64 encoded logo image.
         */
        function exportToExcel(signerName = '', logoBase64 = '') {
            if (!currentReportData || currentReportData.length === 0) {
                showToast('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t Excel.', 'info');
                return;
            }

            const ws_data = [];

            // Add title row
            ws_data.push([currentEventData.name]);
            ws_data.push([]); // Empty row for spacing

            // Add header row
            const header = currentEventData.columns.filter(col => col.show).map(col => col.label);
            ws_data.push(header);

            // Add data rows
            currentReportData.forEach((item, index) => {
                const row = [];
                currentEventData.columns.filter(col => col.show).forEach(col => {
                    if (col.id === 'stt') {
                        row.push(index + 1);
                    } else {
                        row.push(item[col.id] || '');
                    }
                });
                ws_data.push(row);
            });

            // Add signer name and logo if provided
            if (signerName || logoBase64) {
                ws_data.push([]); // Spacer
                ws_data.push([]); // Spacer
                if (logoBase64) {
                    // This is a simplified approach. For actual image embedding in XLSX,
                    // it's more complex and usually requires a server-side library or
                    // a more advanced client-side library than basic SheetJS.
                    // For now, we'll just add a placeholder text.
                    ws_data.push(['[Logo Image]']);
                }
                if (signerName) {
                    ws_data.push(['Ng∆∞·ªùi k√Ω: ' + signerName]);
                }
            }

            const ws = XLSX.utils.aoa_to_sheet(ws_data);

            // Merge title cell
            if (ws_data.length > 0) {
                ws['!merges'] = [{ s: { r: 0, c: 0 }, e: { r: 0, c: header.length - 1 } }];
            }

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, currentEventData.name);
            XLSX.writeFile(wb, `${currentEventData.name}_BaoCao.xlsx`);
            showToast('ƒê√£ xu·∫•t b√°o c√°o ra Excel!', 'success');
        }

        /**
         * Exports the report data to a plain text file.
         * @param {string} signerName - Optional name of the signer.
         * @param {string} logoBase64 - Optional base64 encoded logo image (not directly embedded in TXT).
         */
        function exportToTxt(signerName = '', logoBase64 = '') {
            if (!currentReportData || currentReportData.length === 0) {
                showToast('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t TXT.', 'info');
                return;
            }

            let textContent = `${currentEventData.name}\n\n`;

            const header = currentEventData.columns.filter(col => col.show).map(col => col.label);
            textContent += header.join('\t') + '\n'; // Tab-separated header

            currentReportData.forEach((item, index) => {
                const row = [];
                currentEventData.columns.filter(col => col.show).forEach(col => {
                    if (col.id === 'stt') {
                        row.push(index + 1);
                    } else {
                        row.push(item[col.id] || '');
                    }
                });
                textContent += row.join('\t') + '\n'; // Tab-separated data
            });

            if (signerName || logoBase64) {
                textContent += '\n\n';
                if (logoBase64) {
                    textContent += '[Logo Image Placeholder]\n'; // Placeholder for logo
                }
                if (signerName) {
                    textContent += `Ng∆∞·ªùi k√Ω: ${signerName}\n`;
                }
            }

            const blob = new Blob([textContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentEventData.name}_BaoCao.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast('ƒê√£ xu·∫•t b√°o c√°o ra TXT!', 'success');
        }

        /**
         * Exports the report table and chart as a JPG image.
         * @param {string} signerName - Optional name of the signer.
         * @param {string} logoBase64 - Optional base64 encoded logo image.
         */
        async function exportToJpg(signerName = '', logoBase64 = '') {
            if (!currentEventData) {
                showToast('Vui l√≤ng ch·ªçn m·ªôt s·ª± ki·ªán ƒë·ªÉ xu·∫•t ·∫£nh.', 'info');
                return;
            }

            loadingOverlay.classList.remove('hidden');
            loadingOverlay.querySelector('#loading-text').textContent = 'ƒêang t·∫°o ·∫£nh...';

            try {
                // Create a temporary div to render the content for screenshot
                const tempDiv = document.createElement('div');
                tempDiv.style.backgroundColor = '#1a202c'; // bg-gray-900
                tempDiv.style.padding = '2rem';
                tempDiv.style.color = '#e2e8f0'; // text-gray-100
                tempDiv.style.width = '1200px'; // Fixed width for consistent image output
                tempDiv.style.fontFamily = 'Inter, sans-serif';
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px'; // Hide off-screen

                // Title
                tempDiv.innerHTML += `<h1 style="font-size: 2.25rem; font-weight: 700; text-align: center; margin-bottom: 1.5rem;">Tool Qu·∫£n l√Ω S·ª± ki·ªán ƒêa nƒÉng d√†nh cho Ban L√†m Vi·ªác MSTQ</h1>`;
                tempDiv.innerHTML += `<p style="text-align: center; color: #a0aec0; margin-bottom: 2rem;">B√°o c√°o s·ª± ki·ªán: "${currentEventData.name}"</p>`;

                // Logo
                if (logoBase64) {
                    tempDiv.innerHTML += `<div style="text-align: center; margin-bottom: 1.5rem;"><img src="${logoBase64}" alt="Logo" style="max-height: 80px; display: inline-block; border-radius: 8px;"></div>`;
                }

                // Table content
                const tableHtml = document.getElementById('reportContainer').outerHTML;
                tempDiv.innerHTML += `<div style="background-color: #2d3748; padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); overflow-x: auto; margin-bottom: 2rem;">${tableHtml}</div>`;

                // Chart content
                if (chartInstance) {
                    const chartCanvas = document.getElementById('provinceChart');
                    const chartImage = chartCanvas.toDataURL('image/png'); // Get chart as image
                    tempDiv.innerHTML += `<div style="background-color: #4a5568; padding: 1rem; border-radius: 0.5rem; height: 320px; display: flex; justify-content: center; align-items: center;"><img src="${chartImage}" alt="Chart" style="max-width: 100%; max-height: 100%; object-fit: contain;"></div>`;
                }

                // Signer name
                if (signerName) {
                    tempDiv.innerHTML += `<p style="text-align: right; margin-top: 2rem; font-weight: 600;">Ng∆∞·ªùi k√Ω: ${signerName}</p>`;
                }

                document.body.appendChild(tempDiv);

                // Use html2canvas to capture the content
                const canvas = await html2canvas(tempDiv, {
                    scale: 2, // Increase scale for better quality
                    useCORS: true, // Enable CORS if images are from external sources
                    backgroundColor: null // Transparent background, so the body color shows through
                });

                // Remove the temporary div
                document.body.removeChild(tempDiv);

                // Convert canvas to image and download
                const image = canvas.toDataURL('image/jpeg', 0.9); // 0.9 quality for JPG
                const a = document.createElement('a');
                a.href = image;
                a.download = `${currentEventData.name}_BaoCao.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showToast('ƒê√£ xu·∫•t b√°o c√°o ra ·∫£nh JPG!', 'success');

            } catch (error) {
                console.error("L·ªói khi xu·∫•t ·∫£nh JPG:", error);
                showToast(`L·ªói khi xu·∫•t ·∫£nh: ${error.message}`, 'error');
            } finally {
                loadingOverlay.classList.add('hidden');
                loadingOverlay.querySelector('#loading-text').textContent = 'ƒêang k·∫øt n·ªëi...';
            }
        }

        // --- Responsive Actions Toggle for Mobile ---
        actionsToggleBtn.addEventListener('click', () => {
            actionsContainer.classList.toggle('hidden');
            actionsContainer.classList.toggle('flex');
        });

        // Close actions container when clicking outside on mobile
        document.addEventListener('click', (event) => {
            if (!actionsContainer.contains(event.target) && !actionsToggleBtn.contains(event.target) && window.innerWidth < 768) {
                actionsContainer.classList.add('hidden');
                actionsContainer.classList.remove('flex');
            }
        });

        // Initial load check for eventId from URL
        const urlParams = new URLSearchParams(window.location.search);
        const eventIdFromUrl = urlParams.get('eventId');
        if (eventIdFromUrl) {
            // If an eventId is in the URL, try to load it directly
            // This will be handled after Firebase auth is ready in onAuthStateChanged
            // We store it in localStorage so loadEvents can pick it up
            localStorage.setItem(`selectedEventId_${userId}`, eventIdFromUrl);
        }
    </script>
    <script src="./register-sw.js"></script>
</body>
</html>
